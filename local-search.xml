<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微观经济学</title>
    <link href="/2020/04/18/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    <url>/2020/04/18/%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="微观经济学"><a href="#微观经济学" class="headerlink" title="微观经济学"></a>微观经济学</h1><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><h3 id="第一节-什么是西方经济学"><a href="#第一节-什么是西方经济学" class="headerlink" title="第一节 什么是西方经济学"></a>第一节 什么是西方经济学</h3><ol><li>西方经济学概念： 经济学是研究人们如何合理使用相对稀缺的资源来满足无限多样的需要的一门社会科学萨缪尔森为经济学下的定义为：“经济学是研究人和社会如何进行选择，来使用可以有其他用途的稀缺的资源以便生产各种商品，并在现在或将来把商品分配给社会的各个成员或集团以供消费之用” 从载体上看，西方经济学指大量的与经济问题有关的各种不同的文献、资料和统计报告在这些文献、资料和统计报告中，根据所含的技术分析和经济理论成分的大小，包含了三种类别内容：一是企事业的经营管理方法和经验；二是对一个经济部门或经济领域或经济问题的集中研究成果；三是经济理论的研究和考察三种类别的技术分析的含量依次减少，经济理论的成分依次增加我们所涉及的系指第三种类别的西方经济学。</li><li>资源的稀缺性资源的稀缺性是相对于人类无限的欲望而言的人的需要具有无限增长和扩大的趋势，为了满足这种需要，就要生产更多的物品和劳务，从而需要更多的资源但在一定时期内可用于生产的资源与人们的需要相比总是远远不够的这就是资源的稀缺性经济学所研究的就是如何对有限的资源进行合理的配置以最大程度的满足人们需要的 </li><li>“看不见的手”的原理这是亚当·斯密在著名的《国富论》中提出来的，他说：“每人都在力图应用他的资本，来使其生产品能得到最大的价值一般来说：他并不企图增进公共福利，也不知道他所增进的公共福利为多少他所追求的仅仅是他个人的安乐，仅仅是他个人的利益在这样做时，有一只看不见的手引导他去促进一种目标，而这种目标决不是他所追求的东西由于追逐他自己的利益，他经常促进了社会利益，其效果要比他真正想促进社会利益时所得到的效果为大”“看不见的手”的原理说明，当社会个体追求个人利益时，他被一只看不见的手即市场机制所引导去增进了社会利益微观经济学的主要部分（前十一章的内容）都是对“看不见的手”的原理的论证和注解 </li></ol><h3 id="第二章-西方经济学的由来和演变"><a href="#第二章-西方经济学的由来和演变" class="headerlink" title="第二章 西方经济学的由来和演变"></a>第二章 西方经济学的由来和演变</h3><blockquote><p>西方经济学产生的时期早，其发展经历了以下一个阶段：重商主义（产生于15世纪末期）——古典经济学（产生于17世纪中期，代表人物为威廉·配弟、亚当·斯密、李嘉图等）——古典经济学的庸俗化（产生于19世纪30年代，代表人物为萨伊、马尔萨斯）——边际效用经济学（产生于19世纪70年代，代表人物为门格尔、杰文斯、瓦尔拉斯）——新古典经济学（产生于19世纪末期，代表人物为马歇尔）——凯恩斯经济学（产生于20世纪30年代）——后凯恩斯主流经济学（产生于20世纪中期，代表人物为库兹涅茨、汉森、萨缪尔森、托宾、哈罗德等）——新自由主义经济学（产生于20世纪60年代，由货币学派、供给学派、理性预期学派、新制度经济学、公共选择学派、新左派和新自由主义学派组成）</p></blockquote><h3 id="第三节-西方经济学的理论体系"><a href="#第三节-西方经济学的理论体系" class="headerlink" title="第三节 西方经济学的理论体系"></a>第三节 西方经济学的理论体系</h3><blockquote><p>西方经济学根据它所研究的具体对象、范围不同，可以分为<strong>微观经济学</strong>和<strong>宏观经济学</strong>两个组成部分 </p><p>微观经济学是以单个经济主体（作为消费者的单个家庭、单个厂商或企业、以及单个产品市场）的经济行为作为考察对象的科学，它采用的个量分析的方法，研究的问题主要有：个人或家庭作为消费者如何把有限的收入分配于各种商品的消费上，以获得最大效用；单个生产者如何把有限的生产性资源分配于各种商品的生产上，以获得最大利润；商品市场和要素市场上均衡价格和均衡产量是如何决定的，等等微观经济学的核心是<strong>价格问题</strong></p><p>宏观经济学是把一个社会作为一个整体的经济活动作为考察对象，采用总量分析法，以国民收入为中心，以全社会福利为目标，从总供求的角度研究产品市场、货币市场、国际收支等方面的协调发展，以及怎样通过宏观调控达到资源的充分利用它研究的是诸如社会就业量、物价水平、经济增长、经济周期等全局性的问题 </p><p>微观经济学和宏观经济学之间有着密切的联系它们是整体与个体之间的关系，微观经济学是宏观经济学的基础，如果形象化地把宏观经济学看作研究森林的特征，微观经济学则是考察构成森林的树木, 微观经济学的理论基础是<strong>以马歇尔为代表的新古典经济学</strong>，其<strong>核心</strong>是<strong>市场有效性和自由放任</strong>；宏观经济学的理论基础是<strong>凯恩斯主义经济学</strong>，其<strong>核心</strong>是<strong>市场失效</strong>和*<em>国家干预 *</em></p></blockquote><h3 id="第四节-西方经济学的分析方法"><a href="#第四节-西方经济学的分析方法" class="headerlink" title="第四节 西方经济学的分析方法"></a>第四节 西方经济学的分析方法</h3><blockquote><ol><li>均衡分析均衡是来自于物理学中的一个概念，它分析的是经济力量达到均衡所需要的条件以及均衡达到时会出现的情况，用数学语言来说就是所研究的经济问题中涉及各种变量，假定自变量为已知或不变，考察因变量达到均衡时所需要的条件和会出现的情况均衡分析有局部均衡和一般均衡之分</li><li>实证分析和规范分析与两种分析方法相对应的，经济学理论划分为实证经济学和规范经济学前者在解释今年国际运行时从客观事实本身出发，力求说明和回答经济现象“是什么”和“为什么”的问题，并在此基础上预测经济行为的后果，而不对事物作出好坏、善恶的评价后者以一定的价值判断为出发点，提出行为标准，作出应当与不应当的评价，回答“应该是什么”的问题西方经济学所进行的分析，少数属于规范分析，基本上都属于实证分析 </li><li>静态分析、比较静态分析与动态分析静态分析是考察在既定的条件下某一经济事物在经济变量的相互作用下所实现的均衡状态的特征，它研究的是经济活动的一个横断面比较静态分析是考察当原有的条件发生变化后，原有的均衡状态会发生什么变化，并分析比较新旧均衡状态动态分析是在引进时间变化序列的基础上，研究不同时点上的变量的相互作用在均衡状态的形成和变化过程中所起的作用，考察在时间变化过程中的均衡状态的实际变化过程如果说静态分析考察的是一张静止的照片，而比较静态分析的是几张不同时点的幻灯片，那么动态分析所考察的是一系列连续移动的照片即电影西方经济学中经常使用的比较静态分析法 </li><li>边际分析边际分析是西方经济学的基本分析方法之一，它是通过增量的对比来分析经济行为的边际分析方法实际上微积分在经济学中应用的结果，用微积分的语言来说就是指在一个函数关系中，自变量的微小变化如何引起因变量的相应变化，即微积分的求导问题西方经济学认为，边际量分析比总量分析和平均量分析，能更精确地描述经济变量之间的函数关系  </li></ol></blockquote><h2 id="第二章需求与供给曲线概述以及有关的基本概念"><a href="#第二章需求与供给曲线概述以及有关的基本概念" class="headerlink" title="第二章需求与供给曲线概述以及有关的基本概念"></a>第二章需求与供给曲线概述以及有关的基本概念</h2><h3 id="第一节微观经济学的特点"><a href="#第一节微观经济学的特点" class="headerlink" title="第一节微观经济学的特点"></a>第一节微观经济学的特点</h3><ol><li>微观经济学体系概览概括来说，微观经济学的研究是在三个逐步深入的层次上进行的：第一个层次是研究单个消费者和单个生产者的最优决策问题；第二个层次是研究单个市场的价格的决定问题；第三个层次是研究一个经济社会中所有单个市场的价格的同时决定问题前两个层次的问题可以借助经济循环流动图来加以说明 除了研究单个消费者、单个生产者和单个市场的局部均衡以外，还要分析完全竞争条件下所有单个市场同时均衡（一般均衡）的状态福利经济学又以一般均衡理论为出发点，论述了一般均衡状态符合“帕累托最优状态”此外，微观经济学还包括微观经济政策的分析，以克服“市场失灵”  </li><li>微观经济学的基本假设条件：“经济人”假设；完全信息假设</li></ol><h3 id="第二节-需求曲线"><a href="#第二节-需求曲线" class="headerlink" title="第二节 需求曲线"></a>第二节 需求曲线</h3><blockquote><ol><li>需求：指消费者在一定时期内在各种可能的价格水平下愿意而且能够购买的该商品的数量它包括购买欲望和购买能力两层含义只有购买欲望而没有购买能力，或者只有购买能力而没有购买欲望，都不能算做需求 </li><li>需求函数：是用来表示一种商品的需求数量和影响该商品的各种因素之间的相互关系的影响需求数量的各个因素是自变量，需求数量是因变量，商品的需求数量是所有影响这种商品数量的因素的函数假定其他因素不变，只分析商品的价格对需求量的影响，即把商品的需求量仅仅看成是商品价格的函数，则需求函数可以用下列公式表示：Qd=f（P）（P：商品的价格；Qd：商品的需求量）当需求函数为线性函数时，则线性需求函数的通常形式为：Qd=α-β•P（α、β为常数），该函数所对应的需求曲线为一直线 </li><li>需求定理：指商品的需求量与价格之间的互为反方向的变化关系价格上升，需求量减少；价格下降，需求量增加用几何形式表示商品的需求量与价格之间的这种关系即需求曲线的形状是向右下方倾斜的</li></ol></blockquote><h3 id="第三节-供给曲线"><a href="#第三节-供给曲线" class="headerlink" title="第三节 供给曲线"></a>第三节 供给曲线</h3><blockquote><ol><li>供给：指生产者在一定时期内在各种可能的价格水平下，愿意而且能够提供出售的该种商品的数量它包括供给意愿和供给能力两层含义只有供给意愿而没有供给能力，或者只有供给能力而没有供给意愿，都不能算做供给 </li><li>供给函数：是用来表示一种商品的供给数量和影响该供给数量的各种因素之间的相互关系的影响供给数量的各个因素是自变量，供给数量是因变量，商品的供给数量是所有影响这种商品供给数量的因素的函数假定其他因素不变，只分析商品的价格对供给量的影响，即把商品的供给量仅仅看成是商品价格的函数，则供给函数可以用下列公式表示：Qs=f（P）（P：商品的价格；Qs：商品的供给量）当供给函数为线性函数时，则线性供给函数的通常形式为：Qs=-δ+γ•P（δ、γ为常数），该函数所对应的供给曲线为一直线 </li><li>供给定理：指商品的供给量与价格之间的互为同方向的变化关系价格上升，供给量增加；价格下降，供给量减少用几何形式表示商品的供给量与价格之间的这种关系即供给曲线的形状是向右上方倾斜的供给与价格为正向关系，除了价格以外，供给还受生产成本、生产技术水平、相关商品价格和生产者对未来的预期等因素的影响其他条件不变时，由商品的价格变动所引起的商品的供给数量的变动为供给量的变动；价格不变时，由其他因素的变动所引起的商品的供给数量的变动为需求的变动在假定其他因素不变的条件下，我们可以得到反映价格与供给之间正向关系的供给曲线，即向右上方倾斜的曲线，这就是供给定理</li></ol></blockquote><h3 id="第四节-供求曲线的共同作用"><a href="#第四节-供求曲线的共同作用" class="headerlink" title="第四节 供求曲线的共同作用"></a>第四节 供求曲线的共同作用</h3><blockquote><ol><li>均衡价格：指某种商品的市场需求量和市场供给量相等时的价格从几何意义上说，一种商品市场的均衡出现在该商品的市场需求曲线和市场供给曲线相交的交点上，该交点被称为均衡点均衡点上的价格和相等的供求量分别被称为均衡价格和均衡数量市场上需求量和供给量相等的状态，也被称为市场出清的状态 </li><li>需求量的变动和需求的变动：需求量的变动指在其他条件不变时，由某商品的价格变动所引起的该商品的需求数量的变动需求量的变动表现为变动点在同一条需求曲线上的运动，它并不会引起整个需求状态的变化需求的变动指在商品价格不变的条件下，由于其他因素变动所引起的该商品的需求数量的变动需求的变动表现为需求曲线的位置发生移动，它会引起整个需求状态的变化 </li><li>供给量的变动和供给的变动：供给量的变动指在其他条件不变时，由某商品的价格变动所引起的该商品的供给数量的变动供给量的变动表现为变动点在同一条供给曲线上的运动，它并不会引起整个供给状态的变化供给的变动指在商品价格不变的条件下，由于其他因素变动所引起的该商品的供给数量的变动供给的变动表现为供给曲线的位置发生移动，它会引起整个供给状态的变化 </li><li>供求定理：指在其他条件不变的情况下，需求的变动分别引起均衡价格和均衡数量的同方向的变动；供给变动分别引起均衡价格的反方向变动和均衡数量的同方向变动即需求增加，使均衡价格上升，均衡数量增加；需求减少，使均衡价格下降，均衡数量减少供给增加，使均衡价格下降，均衡数量增加；供给减少，使均衡价格上升，均衡数量减少 </li></ol></blockquote><h3 id="第五节-弹性理论"><a href="#第五节-弹性理论" class="headerlink" title="第五节 弹性理论"></a>第五节 弹性理论</h3><blockquote><ol><li>需求的价格弹性：表示在一定时期内一种商品的需求量变动对于该商品的价格变动的反映程度其公式为：需求的价格弹性系数=需求量变动率/价格变动率 </li><li>需求的价格弧弹性：表示某商品需求曲线上两点之间的需求量的变动对于价格的变动的反应程度即指需求曲线上两点之间的弹性其公式为：ed=-(ΔQ/ΔP)•(P/Q)式中ΔQ和ΔP分别表示需求量和价格的变动量，ed表示需求的价格弹性系数 </li><li>需求的价格点弹性：表示需求曲线上某一点上的需求量的变动对于价格变动的反应程度即指需求曲线上某一点的弹性其公式为：ed=-(dQ/dP)•(P/Q) </li><li>供给的价格弹性：表示在一定时期内一种商品的供给量的变动对于该商品的价格变动的反应程度它是商品的供给量变动率与价格变动率之比 </li><li>需求的交叉价格弹性：表示在一定时期内一种商品的需求量的变动对于它的相关商品的价格的变动的反应程度它是该商品的需求量的变动率和它的相关商品的价格的变动率的比值需求的交叉价格弧弹性公式为：exy=(ΔQx/ΔPy)•(Py/Qx)式中exy为当Y商品的价格发生变化时X商品的需求的交叉价格弹性系数；ΔQx为商品X的需求量的变化量；ΔPy为相关商品Y的价格的变化量需求的交叉价格点弹性公式为：exy=(dQx/dPy)•(Py/Qx) </li><li>替代品：如果两种商品之间可以互相代替以满足消费者的某一种欲望，则称这两种商品之间存在着替代关系，这两种商品互为替代品 </li><li>互补品：如果两种商品必须同时使用才能满足消费者的某一种欲望，则称这两种商品之间存在着互补关系，这两种商品互为互补品 </li><li>需求的收入弹性：表示在一定时期内消费者对某种商品的需求量的变动对于消费者收入量变动的反应程度它是商品的需求量的变动率和消费者的收入量的变动率的比值其公式为：em=(ΔQ/ΔM)•(M/Q)，或为：em=(dQ/dM)•(M/Q)式中em为需求的收入弹性系数；M为消费者的收入水平 </li><li>恩格尔定律：在一个家庭或在一个国家中，食物支出在收入中所占的比例随着收入的增加而减少用弹性概念来表述恩格尔定律为：对于一个家庭或一个国家来说，富裕程度越高，则食物支出的收入弹性就越小；反之，则越大 </li></ol></blockquote><h3 id="第六节-均衡价格和弹性理论的应用"><a href="#第六节-均衡价格和弹性理论的应用" class="headerlink" title="第六节 均衡价格和弹性理论的应用"></a>第六节 均衡价格和弹性理论的应用</h3><blockquote><p>在上述分析的基础上，本章还讨论了均衡价格和弹性理论的应用，如需求的价格弹性对厂商销售收入有影响，一般的，对于富有弹性的商品，降价会使厂商的收益增加，提价会使收益减少；对于单一弹性的商品，价格的升降不会使收益发生变化；对于缺乏弹性的商品，降价会使收益减少，提价会使收益增加此外，还有易腐商品的售卖、最低限价和最高限价、谷贱伤农等运用供求曲线的事例说明政府如何干预市场价格，以及生产者应如何利用供求理论和弹性理论为经济决策服务 </p></blockquote><h3 id="第七节-蛛网模型"><a href="#第七节-蛛网模型" class="headerlink" title="第七节 蛛网模型"></a>第七节 蛛网模型</h3><blockquote><p>蛛网模型引进时间变化的因素，通过对属于不同时期的需求量、供给量和价格之间的相互作用的考察，用动态分析的方法论述诸如农产品、畜牧产品等生产周期较长的商品的产量和价格在偏离均衡状态后的实际波动过程及其结果蛛网模型分析了商品的价格和产量波动的三种情况：收敛型蛛网、发散型蛛网和封闭型蛛网</p></blockquote><h2 id="第三章-效用论"><a href="#第三章-效用论" class="headerlink" title="第三章 效用论"></a>第三章 效用论</h2><h3 id="第一节-效用论概述"><a href="#第一节-效用论概述" class="headerlink" title="第一节 效用论概述"></a>第一节 效用论概述</h3><blockquote><ol><li>基数效用论：基数效用论者认为效用可以用基数衡量，并认为商品的边际效用递减消费者应该使自己所购买的各种商品的边际效用和价格之比相等，且等于货币的边际效用，才能实现效用最大化在货币的边际效用不变的前提下，商品的需求价格必然随商品的消费数量的增加而递减 </li><li>序数效用论：序数效用论者用偏好来反映消费者对效用的评价，并用无差异曲线来表示消费者偏好相同的两种商品的所有组合消费者的均衡是在无差异曲线和预算线的切点处得到据此得到价格——消费曲线，并进一步推导出消费者的需求曲线 </li><li>边际效用递减规律：在一定时间内，在其他商品的消费数量保持不变的条件下，随着消费者对某种商品消费量的增加，消费者从该商品连续增加每一消费单位中所得到的效用增量即边际效用是递减的 </li><li>消费者均衡：是研究单个消费者如何把有限的货币收入分配在各种商品的购买中以获得最大的效用也可以说，它是研究单个消费者在既定收入下实现效用最大化的均衡条件 </li><li>消费者剩余：是消费者在购买一定数量的某种商品时愿意支付的总数量和实际支付的总数量之间的差额 </li></ol></blockquote><h3 id="第二节-无差异曲线"><a href="#第二节-无差异曲线" class="headerlink" title="第二节 无差异曲线"></a>第二节 无差异曲线</h3><blockquote><ol><li>偏好：序数效用论者提出偏好的概念，用来表示消费者对效用水平的评价偏好具有完全性、可传递性、非饱和性三个基本假定 </li><li>无差异曲线：是用来表示消费者偏好相同的两种商品的所有组合的曲线或者说，它表示能给消费者带来相同的效用水平或满足程度的两种商品的所有组合的曲线 </li><li>商品的边际替代率（MRS）：在维持效用水平不变的前提下，消费者增加一单位某种商品的消费数量时所需要放弃的另一种商品的消费数量 </li><li>边际替代率递减规律：在维持效用水平不变的前提下，随着一种商品消费数量的增加，消费者为得到这种商品所愿意放弃的另一种商品的数量是递减的 </li><li>无差异曲线的特殊形状：完全替代品和完全互补品的无差异曲线的形状是特殊的  </li></ol></blockquote><h3 id="第三节-预算线"><a href="#第三节-预算线" class="headerlink" title="第三节 预算线"></a>第三节 预算线</h3><blockquote><ol><li>预算线：表示在消费者的收入和商品的价格给定的条件下，消费者的全部收入所能购买到的两种商品的各种组合的曲线 </li><li>预算线的变动：当消费者的收入和两商品的价格这几个变量中的一个或几个发生变化，预算线的位置就会受到影响 </li></ol></blockquote><h3 id="第四节-消费者的均衡"><a href="#第四节-消费者的均衡" class="headerlink" title="第四节 消费者的均衡"></a>第四节 消费者的均衡</h3><blockquote><p>消费者均衡条件:消费者的最优商品组合应位于预算线和无差异曲线的切点处</p></blockquote><h3 id="第五节-价格变化和收入变化对消费者均衡的影响"><a href="#第五节-价格变化和收入变化对消费者均衡的影响" class="headerlink" title="第五节 价格变化和收入变化对消费者均衡的影响"></a>第五节 价格变化和收入变化对消费者均衡的影响</h3><ol><li>收入——消费曲线：是在消费者偏好和商品价格不变情况下，收入变化所引起的消费者均衡点变化的轨迹 </li><li>恩格尔曲线：是以19世纪德国著名统计学家恩格尔的名字命名的曲线凡是反映收入变化与某种商品消费量变化之间关系的曲线都被称为恩格尔曲线 </li><li>价格——消费曲线：连接所有消费者效用最大化的均衡点的轨迹，形成价格——消费曲线  </li></ol><h3 id="第六节-替代效应和收入效应"><a href="#第六节-替代效应和收入效应" class="headerlink" title="第六节 替代效应和收入效应"></a>第六节 替代效应和收入效应</h3><blockquote><ol><li>替代效应：由商品的价格变动所引起的商品相对价格的变动，进而由商品的相对价格变动所引起的商品需求量的变动为替代效应它不改变消费者的效用水平 </li><li>收入效应：由商品的价格变动所引起的实际收入水平变动，进而由实际收入水平变动所引起的商品需求量的变动为收入效应它表示消费者的效用水平发生变化 </li><li>正常物品：指需求量与消费者的收入水平呈同方向的变动的商品，即：正常物品的需求量随着消费者收入水平的提高而增加，随着消费者的收入水平的下降而减少 </li><li>低档物品：指需求量与消费者的收入水平呈反方向的变动的商品，即：低档物品的需求量随着消费者收入水平的提高而减少，随着消费者的收入水平的下降而增加 5吉芬物品：指需求量与价格呈同方向变动的特殊的低档物品 </li></ol></blockquote><h3 id="第七节-从单个消费者的需求曲线到市场需求曲线"><a href="#第七节-从单个消费者的需求曲线到市场需求曲线" class="headerlink" title="第七节 从单个消费者的需求曲线到市场需求曲线"></a>第七节 从单个消费者的需求曲线到市场需求曲线</h3><blockquote><p>从单个消费者的需求曲线到市场需求曲线的推导：将市场上所有个人的需求曲线水平加总即可得到市场的需求曲线市场需求曲线也向右下方倾斜，每个点都表示在相应价格水平下可以给全体消费者带来最大效用水平的市场需求量 </p></blockquote><h3 id="第八节-不确定性和风险"><a href="#第八节-不确定性和风险" class="headerlink" title="第八节 不确定性和风险"></a>第八节 不确定性和风险</h3><blockquote><ol><li>不确定性：指经济行为者在事先不能准确的知道自己的某种决策的结果，或者说，只要经济行为者的一种决策的可能结果不止一种，就会产生不确定性 </li><li>期望效用：指消费者在不确定条件下可能得到的各种结果的效用的加权平均数 </li><li>降低风险的方法：常见的有多样化、购买保险和获取更多信息三种方法  </li></ol></blockquote><h2 id="第四章-生产论"><a href="#第四章-生产论" class="headerlink" title="第四章 生产论"></a>第四章 生产论</h2><h3 id="第一节-厂商"><a href="#第一节-厂商" class="headerlink" title="第一节 厂商"></a>第一节 厂商</h3><blockquote><ol><li>厂商的组织形式：生产者亦称厂商或企业，它是指能够做出统一的生产决策的单个经济单位其组织形式有个人企业、合伙制企业和公司制企业 </li><li>企业本质：一般从交易成本的角度来分析企业的本质 </li><li>厂商的目标：一般假定为追求利润最大化</li></ol></blockquote><h3 id="第二节-生产函数"><a href="#第二节-生产函数" class="headerlink" title="第二节 生产函数"></a>第二节 生产函数</h3><blockquote><ol><li>生产函数：生产函数表示在一定时期内，在技术水平不变的情况下，生产中所使用的各种生产要素的数量与所能生产的最大产量之间的关系 </li><li>生产要素：在西方经济学中，生产要素一般被划分为劳动、土地、资本和企业家才能这四种类型劳动指人类在生产过程中提供的体力和智力的总和土地不仅指土地本身，还包括地上和地下的一切自然资源资本可以表现为实物形态或货币形态资本的实物形态又称为资本品或投资品资本的货币形态通常称为货币资本企业家才能指企业家组织建立和经营管理企业的才能 </li><li>固定投入比例生产函数：也称为里昂惕夫生产函数，指在每一个产量水平上任何一对要素投入量之间的比例都是固定的生产函数假定生产过程中只使用劳动和资本两种要素，则固定投入比例生产函数的通常形式为：Q=(Minimum)(L／u，K／v)式中，Q为产量；L和K分别为劳动和资本的投入量；常数u和V分别为固定的劳动和资本的生产技术系数，它们分别表示生产一单位产品所需要固定的劳动投入量和资本投入量 </li><li>柯布一道格拉斯生产函数：是由数学家柯布和经济学家道格拉斯于本世纪30年代初一起提出来的其一般形式为：Q=ALαKβ式中，Q为产量；L和K分别为劳动和资本投入量；A、α和β为三个参数，0&lt;α、β&lt;1当α+β=1时，α和β分别表示劳动和资本在生产过程中的相对重要性，α为劳动所得在总产量中所占的份额，β为资本所得在总产量中所占的份额 </li></ol></blockquote><h3 id="第三节-一种可变要素的生产函数"><a href="#第三节-一种可变要素的生产函数" class="headerlink" title="第三节 一种可变要素的生产函数"></a>第三节 一种可变要素的生产函数</h3><blockquote><ol><li>生产的短期和长期：短期指生产者来不及调整全部生产要素的数量，至少有一种生产要素是固定不变的时间周期长期指生产者可以调整全部生产要素的数量的时间周期 </li><li>总产量、平均产量和边际产量：总产量是指与一定的可变要素的投入量相对应的最大产量平均产量是总产量与所使用的可变要素的投入量之比边际产量是增加一单位可变要素劳动投入量所增加的产量 </li><li>边际报酬递减规律：对于任何产品的短期生产来说，可变要素投入和固定要素之间都存在着一个最佳的数量组合比例在技术水平不变的条件下，在连续等量地把某一种可变生产要素增加到其他一种或几种数量不变的生产要素上去的过程中，当这种可变生产要素的投入量小于某一特定值，增加该要素投入所带来的边际产量是递增的；当这种可变要素的投入量连续增加并超过这个特定值时，增加该要素投入所带来的边际产量是递减的，这就是边际报酬递减规律它是短期生产的一条基本规律 </li><li>TPL、APL、MPL的相互关系：MPL是TPL曲线的切线斜率，边际产出最大时总产出曲线斜率最大，边际产出为零时总产出最大APL是TPL曲线上任一点与原点连线的斜率值，边际产出曲线交平均产出曲线与平均产出曲线的最高点，交点之左平均产出小于边际产出，交点之右平均产出大于边际产出 </li><li>生产的三个阶段：短期生产可划分为三个阶段，分界点分别为平均产出最高点和总产出最高点</li></ol></blockquote><h3 id="第四节-两种可变要素的生产函数"><a href="#第四节-两种可变要素的生产函数" class="headerlink" title="第四节 两种可变要素的生产函数"></a>第四节 两种可变要素的生产函数</h3><blockquote><ol><li>等产量曲线：是在技术水平不变的条件下生产同一产量的两种生产要素投入量的所有不同组合的轨迹以常数Q0表示既定的产量水平，则与等产量曲线相对应的生产函数为：Q=f(L，K)=Q0 </li><li>边际技术替代率递减规律：在维持产量不变的前提下，当一种生产要素的投入量不断增加时，每一单位的这种生产要素所能替代的另一种生产要素的数量是递减的，这一现象被称为边际技术替代率递减规律这一规律的产生原因在于任何一种产品的生产技术都要求各要素投入之间保持适当比例，这意味着要素之间的替代是有限的边际技术替代率递减规律使得等产量曲线呈现出突向原点的特点 </li><li>等成本线：是在既定的成本和既定的生产要素价格条件下生产者可以购买到的两种生产要素的各种不同数量组合的轨迹 </li><li>两种生产要素的最优组合：即既定成本条件下的产量最大或既定产量条件下的成本最小是等产量线与等成本线的切点处两要素的数量组合满足边际技术替代率等于两要素价格之比 </li><li>等斜线：是一组等产量曲线中两要素的边际技术替代率相等的点的轨迹 </li><li>扩展线：在生产要素的价格、生产技术和其他条件不变时，如果企业改变成本，等成本线就会发生平移；如果企业改变产量，等产量曲线就会发生平移这些不同的等产量曲线将与不同的等成本线相切，形成一系列不同的生产均衡点，这些生产均衡点的轨迹就是扩展线 </li><li>规模报酬：规模报酬变化是指在其他条件不变的情况下，企业内部各种生产要素按相同比例变化时所带来的产量变化企业的规模报酬变化可以分规模报酬递增、规模报酬不变和规模报酬递减三种情况 </li></ol></blockquote><h2 id="第五章-成本论"><a href="#第五章-成本论" class="headerlink" title="第五章 成本论"></a>第五章 成本论</h2><h3 id="第一节-成本的概念"><a href="#第一节-成本的概念" class="headerlink" title="第一节 成本的概念"></a>第一节 成本的概念</h3><blockquote><ol><li>机会成本：生产一单位的某种商品的机会成本是指生产者所放弃的使用相同的生产要素在其他生产用途中所能得到的最高收入 </li><li>显成本：企业生产的显成本是指厂商在生产要素市场上购买或租用所需要的生产要素的实际支出 </li><li>隐成本：企业生产的隐成本是指厂商本身所拥有的且被用于该企业生产过程的那些生产要素的总价格 </li><li>经济利润：企业的经济利润指企业的总收益和总成本之间的差额，简称企业的利润 </li><li>正常利润：指厂商对自己所提供的企业家才能的报酬的支付 </li></ol></blockquote><h3 id="第二节-短期总产量和短期总成本"><a href="#第二节-短期总产量和短期总成本" class="headerlink" title="第二节 短期总产量和短期总成本"></a>第二节 短期总产量和短期总成本</h3><blockquote><ol><li>短期总产量曲线和短期总成本曲线的关系：在产量函数中产量与劳动之间存在对应关系，可以理解为厂商根据不同产量水平的要求，来确定劳动的投入量劳动量影响着可变成本，所以可由短期生产函数推导出短期成本函数 </li><li>由扩张线到短期总成本线：在扩张线上某一点处，K和L存在一最佳组合若K保持不变，沿着K水平线左右移动，会与不同成本曲线相交，这些交点处也包含着某一成本，这样就得到无数个产量与相应的短期成本的组合，所以，短期成本线也可在扩张线图中得以说明</li></ol></blockquote><h3 id="第三节-短期成本曲线"><a href="#第三节-短期成本曲线" class="headerlink" title="第三节 短期成本曲线"></a>第三节 短期成本曲线</h3><blockquote><ol><li>短期成本：在短期，厂商的成本有不变成本部分和可变成本部分之分具体讲，厂商的短期成本有以下七种：总不变成本、总可变成本、总成本、平均不变成本、平均可变成本、平均总成本和边际成本</li><li>固定成本：是指不随产量变化而变化的成本 </li><li>可变成本：是随产量的变化而变化的成本 </li><li>平均成本：是平均每单位产量需要支出的成本是总成本曲线上任意一点与原点连线的斜率当这一总的量分别为总不变成本、总可变成本、总成本时，这一平均值分别为平均不变成本、平均可变成本、平均总成本 </li><li>边际成本：是增加一单位产量所引起的总成本的增量根据边际报酬递减规律，边际成本曲线成先下降后上升的形状边际成本是总成本曲线的斜率，所以总成本曲线的斜率也是先下降后上升的</li></ol></blockquote><h3 id="第四节-短期产量曲线与短期成本曲线之间的关系"><a href="#第四节-短期产量曲线与短期成本曲线之间的关系" class="headerlink" title="第四节 短期产量曲线与短期成本曲线之间的关系"></a>第四节 短期产量曲线与短期成本曲线之间的关系</h3><blockquote><ol><li>边际产量和边际成本存在反相关关系，所以，两者的变动方向相反，且二者极值点相对应；总产量和总成本曲线之间凹凸性相反，且拐点对应 </li><li>平均产量和平均可变成本存在反相关关系，所以，两者的变动方向相反，且二者极值点相对应；由于边际产出曲线交平均产出曲线于平均产出曲线的最高点，所以，边际成本曲线交平均可变成本曲线于平均可变成本曲线的最低点</li></ol></blockquote><h3 id="第五节-长期总成本"><a href="#第五节-长期总成本" class="headerlink" title="第五节 长期总成本"></a>第五节 长期总成本</h3><blockquote><ol><li>长期成本：在长期内，厂商可以根据产量的要求调整全部的生产要素投入量，甚至进入或退出一个行业，因此，厂商所有的成本都是可变的厂商的长期成本可以分为长期总成本、长期平均成本和长期边际成本 </li><li>长期总成本曲线是无数条短期总成本曲线的包络线，在这条包络线上，在连续变化的每一个产量水平上，都存在着LTC曲线与一条STC曲线的相切点，该STC曲线所代表的生产规模就是生产该产量的最优生产规模，该切点所对应的总成本就是生产该产量的最低总成本 </li><li>由扩张线到长期总成本线：扩张线是生产者均衡点的轨迹，均衡点处包含着产量与成本的最佳组合，所以由扩张线可推导出短期总成本线</li></ol></blockquote><h3 id="第六节-长期平均成本与长期边际成本"><a href="#第六节-长期平均成本与长期边际成本" class="headerlink" title="第六节 长期平均成本与长期边际成本"></a>第六节 长期平均成本与长期边际成本</h3><blockquote><ol><li>规模经济和规模不经济：在企业生产扩张的开始阶段，厂商由于扩大生产规模而使经济效益得到提高，这叫规模经济当生产扩张到一定的规模以后，厂商继续扩大生产规模，就会使经济效益下降，这叫规模不经济 </li><li>LAC曲线形状：在规模经济阶段，随着生产规模的扩大，平均成本会逐渐降低，在规模不经济阶段，随着生产规模的扩大，平均成本会逐渐提高，所以LAC曲线呈现出先下降后上升的“U”字形形状 </li><li>外在经济和外在不经济：企业外在经济是由于厂商的生产活动所领带的外界环境得到改善而产生的相反，如果厂商的生产活动所依赖的外界环境恶化了，则是企业的外在不经济外在经济会使LAC曲线向下平移，外在不经济会使LAC曲线向上平移 </li><li>LMC曲线：由LAC与LMC之间的关系及LAC曲线的形状可知，LMC曲线也成U形当LAC曲线下降时，LMC曲线一定处于LAC曲线的下方，即LMC曲线降LAC向下拉；当LAC曲线上升时，LMC曲线一定处于LAC曲线的上方，即LMC曲线将LAC向上拉  </li></ol></blockquote><h2 id="第六章-完全竞争的市场"><a href="#第六章-完全竞争的市场" class="headerlink" title="第六章 完全竞争的市场"></a>第六章 完全竞争的市场</h2><blockquote><p>本章安全竞争的市场和下章不完全竞争的市场构成了市场论，主要说明在消费者和厂商的经济行为的相互作用下，不同类型的市场的价格和产量的决定</p></blockquote><h3 id="第一节-厂商和市场的类型"><a href="#第一节-厂商和市场的类型" class="headerlink" title="第一节 厂商和市场的类型"></a>第一节 厂商和市场的类型</h3><blockquote><ol><li>市场类型划分的标准:市场类型划分的标准是是市场竞争程度的强弱而决定市场竞争程度强弱的有四个因素：第一、市场上厂商的数目，如果厂商数目越多，竞争程度越强第二、厂商之间各自提供的产品的差别程度这里的差别是指同种产品的差别它不是指汽车和自行车的差别，而是指自行车在质量、包装、牌号或销售条件方面的差别产品的差别会形成垄断，因此差别越小，竞争越强第三、单个厂商对市场价格的控制程度单个厂商对市场的控制程度越小，市场的竞争程度越强，比如每户农民作为农产品的供给者，他只是市场的被动接受者，而不能控制市场第四，厂商进入或退出一个行业的难易程度厂商进入一个行业越难，越易形成垄断，比如邮电行业、通讯行业，铁路运输行业就容易形成垄断，因为它的成本非常大，一般人没法界入根据由上竞争程度的强弱，微观经济学把市场划分为四个类型：完全竞争市场、垄断竞争市场、寡头市场和垄断市场这几个市场的竞争程度由强到弱 </li><li>市场：就是一组为买卖某种商品而相互发生联系的厂商和个人 </li><li>厂商：是指以利润最大化为目标向市场提供商品和劳务的独立经营单位 </li><li>行业：为同一市场提供商品的所有厂商的总和 </li></ol></blockquote><h3 id="第二节-完全竞争厂商的需求曲线和收益曲线"><a href="#第二节-完全竞争厂商的需求曲线和收益曲线" class="headerlink" title="第二节 完全竞争厂商的需求曲线和收益曲线"></a>第二节 完全竞争厂商的需求曲线和收益曲线</h3><blockquote><ol><li>完全竞争市场的条件： 第一、市场上有很多的买者和卖者供给者和需求者都非常多，他们中的任何一个人买或不买，卖或不卖都不会对整个产品市场的价格产生影响也就是说厂商和消费者都是价格的被动接受者 第二、同一行业的每一个厂商生产的产品是完全无差别 第三、厂商进入或退出一个行业是完全自由的厂商进入一个行业不存在障碍，所有的资源都可以在各行业之间自由流动在此过程中，优胜劣汰，缺乏效率的企业会被淘汰 第四、市场中的每一个买者和卖者都掌握与自己的经济决策有关的商品和市场的全部信息也就是厂商和消费者都能掌握完全的信息 </li><li>完全竞争市场的需求曲线和完全竞争厂商的需求曲线 完全竞争市场的需求曲线：即整个行业所面临的需求曲线，因为市场总是与行业联系在一起的市场的需求曲线也就是行业的需求曲线是一条向右下方倾斜的曲线 完全竞争厂商的需求曲线：是一条由既定的市场均衡价格水平出发的水平线 </li><li>完全竞争厂商的收益曲线 厂商的收益可以分为总收益、平均收益、边际收益它们的英文简写分别为TR、AR、MR 总收益：指按一定价格出售一定量产品时所获得的全部收入用P表示产品的市场价格，以Q表示销售的总量，则总收益的用公式表示就是TR（Q）=P·Q 平均收益：厂商在平均每一单位产品销售上所获得的收入：AR=TR（Q）/Q 边际收益：厂商增加一单位产品销售所获得的收入增量即：MR=ΔTR（Q）/ΔQ 当ΔQ趋近于0时，MR就是对应的总收益曲线的斜率 完全竞争厂商的收益曲线 总收益是一条通过原点的直线，它的斜率等于P 完全竞争厂商的需求曲线、平均收益曲线、边际收益曲线重合 </li></ol></blockquote><h3 id="第三节-厂商实现利润最大化的均衡条件"><a href="#第三节-厂商实现利润最大化的均衡条件" class="headerlink" title="第三节 厂商实现利润最大化的均衡条件"></a>第三节 厂商实现利润最大化的均衡条件</h3><blockquote><p>厂商实现最大利润的均衡条件：边际收益等于边际成本这里的均衡是达到最大利润时，厂商既不想增加产量，也不想减少产量这样一种相对平衡的状态 假定厂商的总收益函数为TR=TR（Q）总成本函数为TC=TC（Q），那么利润以π表示，则利润π（Q）=TR（Q）-TC（Q）当利润达到最大值时，也就是利润的一阶导数为0时，即π’（Q）=TR’（Q）-TC’（Q）=0总收益的一阶导数是MR，总成本的一阶导数是MC，所以上式又可以写为MR=MC所以厂商可以根据MR=MC来确定最优的产量，以实现最大利润 MR=MC这一利润最大化的条件，对于完全竞争市场和不完全竞争市场的长期生产和短期生产都是适用的 </p></blockquote><h3 id="第四节-完全竞争厂商的短期均衡和短期供给曲线"><a href="#第四节-完全竞争厂商的短期均衡和短期供给曲线" class="headerlink" title="第四节 完全竞争厂商的短期均衡和短期供给曲线"></a>第四节 完全竞争厂商的短期均衡和短期供给曲线</h3><blockquote><ol><li>完全竞争厂商的短期均衡：单个厂商是市场价格的接受者，那么市场价格可能高也可能低，不同的市场价格水平将直接影响厂商的短期均衡的盈亏状况在不同的市场价格的条件下，厂商的盈亏状况一共可以分为以下五种情况（如图6-6所示）： <ul><li>第一种情况，当市场价格为p1时，厂商的需求曲线为d1，利润最大化的均衡点为E1，这时平均收益大于平均总成本利润相当于图中的P1H1F1E1面积，厂商是获利的 </li><li>第二种情况当市场价格为P2时，这时的平均收益的平均成本这时厂商的利润刚好为0，也就是说厂商的经济利润为0，但是它实现了作为企业家报酬的正常利润这时，厂商既无利润，又无亏损这点是短期边际成本与短期平均成本的交点，这点也称为厂商的收支相抵点   </li><li>第三种情况当市场价格为P3时，这时边际收益等于边际成本的利润最大化的均衡点为E3，在该点的平均收益小于平均总成本，但是平均收益大于平均可变成本在该点厂商是亏损的，亏损额为F3E3·OQ3但是，在这点，厂商仍然继续生产因为在这点，平均收益大于平均可变成本，厂商用全部收益弥补了全部可变成本之后，还能弥补一部分固定成本不论生产或不生产固定成本总是存在的 </li><li>第四种情况当市场价格为P4时，这时平均收益等于平均可变成本即AR=AVC，在该点厂商是亏损的，这时全部收益都用来弥补可变成本，生产不生产固定成本都是存在的它处于生产与不生产的临界点这一点也是平均可变成本的最低点，通常称该点为停止营业点或关闭点 </li><li>第五种情况当市场价格下降的更低为P5时，这时平均收益小于平均可变成本，若厂商继续生产，全部收益没法弥补可变成本，更不要说弥补固定成本了，显然，此时，不生产要比生产强 所以，完全竞争厂商的短期均衡条件是：MR=SMC 其中，MR=AR=P，在短期均衡时，厂商可以获得最大利润，可以是利润为0，也可以是亏损 </li></ul></li><li>完全竞争厂商的短期供给曲线：是短期边际成本曲线上等于和高于平均可变成本AVC最低点的部分它是向右上方倾斜的一条曲线，表示在其它条件不变的情况下，生产者在每一个价格愿意而且能够提供的产品的数量更重要的是，生产者所提供的产品数量是在既定价格水平下能够给他带来最大利润或最小亏损的产量数量 </li><li>生产者剩余：厂商的提供一定数量的某种产品时实际接受的总支付和愿意接受的最小总支付之间的差额它通常用市场价格线以下，厂商的供给曲线以上的面积来表示 </li></ol></blockquote><h3 id="第五节-完全竞争行业的短期供给曲线"><a href="#第五节-完全竞争行业的短期供给曲线" class="headerlink" title="第五节 完全竞争行业的短期供给曲线"></a>第五节 完全竞争行业的短期供给曲线</h3><blockquote><p>完全竞争行业的短期供给曲线：行业内所有厂商的供给曲线的水平加合或者说是把完全竞争行业内所有厂商的SMC曲线上等于和高于AVC曲线最低点的部分水平相加，便构成该行业的短期供给曲线行业的短期供给曲线也是向右上方倾斜的而且行业的短期供给曲线上的每一点都表示在相应价格水平下能够使全体厂商获得最大利润（或最小亏损）的行业短期供给量 </p></blockquote><h3 id="第六节-完全竞争厂商的长期均衡"><a href="#第六节-完全竞争厂商的长期均衡" class="headerlink" title="第六节 完全竞争厂商的长期均衡"></a>第六节 完全竞争厂商的长期均衡</h3><blockquote><p>在长期内所有的生产要素都可以改变，厂商通过对全部生产要素的投入量的调整，来实现利润最大化的均衡条件MR=LMC完全竞争厂商在长期内对生产要素的调整可以通过两个方面，第一，厂商进入或退出一个行业，另一方面，厂商对生产规模的调整 </p><ol><li>厂商进入或退出一个行业：在长期内如果一个行业可以获得利润，则会吸引其它新的厂商加入到该行业的生产中来，随着新厂商加入，整个行业的供给增加，市场的价格就会下降，直到下降到使单个厂商的利润消失为止相反，如果行业内单个厂商是亏损的，则一部分厂商就会退出，整个行业的供给减少，市场的价格变会上升，直到上升到使单个厂商的亏损消失为止最后，平均收益等于最低的长期平均成本，既无利润又无亏损，利润为0行业内厂商的进入和退出也就停止了，这时，完全竞争厂商处于一种长期均衡状态 </li><li>厂商对最优生产规模的选择：长期内市场价格会随着行业内厂商数目的变化而变化，而在每一个变化了的价格水平，单个厂商都会将生产规模调整到与均衡条件下的产量水平相对应的最优生产规模，最后会调整到利润为0长期均衡所要求的产量相适应的最优的生产规模我们可以 厂商对生规模的不断调整，直到行业内单个厂商的利润和亏损都消失为止也就是说在图中，厂商最后必然在长期平均成本LAC的最低点实现长期均衡，对应规模为最优的生产规模，商品的市场价格等于最低的长期平均成本 通过以上的分析，我们得出完全竞争厂商的长期均衡点出现在LAC曲线的最低点同时也得出完全竞争厂商长期均衡的条件为： MR=LMC=SMC=LAC=SAC，其中，MR=AR=P，此时，单个厂商的利润为0 </li></ol></blockquote><h3 id="第七节-完全竞争行业的长期供给曲线"><a href="#第七节-完全竞争行业的长期供给曲线" class="headerlink" title="第七节 完全竞争行业的长期供给曲线"></a>第七节 完全竞争行业的长期供给曲线</h3><blockquote><p>在实现长期均衡的过程中，行业的产量会发生变化，那么所需要的生产要素的量也会发生改变，我们说如果一个厂商产量的变化不会影响生产要素的价格，但是如果整个行业产量的变化就会影响生产要素的价格根据生产要素价格的变化长期供给曲线分为三种类型：对于成本不变的行业长期供给曲线是水平的；对于成本递增的行业，长期供给曲线是向右上方倾斜的；对于成本递减的行业，长期供给曲线是向右下方倾斜的 </p><ol><li>成本不变行业的长期供给曲线：成本不变行业就是这样一种行业，它的产量的变化所引起的生产要素需求的变化，不对生产要素的价格发生影响这可能是因为这个行业的生产要素的需求量，只占生产要素市场需求量的很小一部分在这种情况下，行业的长期供给曲线是一条水平线它表示：在长期内，成本不变行业是在不变的均衡价格下提供产量的，这个均衡价格水平等于单个厂商的不变的最低平均成本整个行业的均衡产量会因市场需求的增减而增减，而长期的均衡价格却不会发生变化 </li><li>成本递增行业的长期供给曲线：成本递增行业的这样一种行业，它的产量增加所引起的生产要素需求的增加，会导致生产要素价格的上升在这种情况下，行业的长期供给曲线是一条向右上方倾斜的曲线它表示：随着成本递增行业供给量的增加，长期供给价格是不断上升的市场需求的变化不仅引起行业长期均衡产量的同方向的变化，还引起市场均衡价格的同方向的变化 </li><li>成本递减行业的长期供给曲线：成本递减行业是这样一种行业，它的产量的增加所引起生产要素的增加，反而使生产要素的价格下降了行业成本递减的原因是外在经济的作用，行业产量增加，使单个企业的生产效率提高，从而使成本递减成本递减行业的长期供给曲线是向右下方倾斜的它表示：成本递减行精兵长期供给价格随着行业长期供给量的增加而下降市场需求的变化引起行业长期均衡产量的同方向的变化和市场均衡价格的反方向的变化</li></ol></blockquote><h3 id="第八节-完全竞争市场的短期均衡和长期均衡"><a href="#第八节-完全竞争市场的短期均衡和长期均衡" class="headerlink" title="第八节 完全竞争市场的短期均衡和长期均衡"></a>第八节 完全竞争市场的短期均衡和长期均衡</h3><blockquote><ol><li>完全竞争市场的效率：<ul><li>第一，竞争的长期均衡点上，消费者的效用达到最大化，生产者的利润达到最大化，消费者和生产者之间交易的收益实现了最大化这种交易收益是消费者剩余加生产者剩余的总和</li><li>第二，竞争的长期均衡点上，厂商的生产成本降到了最低水平，等于最低的长期平均成本，</li><li>第三，市场的长期均衡价格也降到了这一最低水平</li><li>第四，市场刚好出清，既不存在供不应求，又不存在产品过剩所以，完全竞争市场的效率是最高的 </li></ul></li><li>消费者统治：指消费者在商品的生产中起决定作用消费者需要什么东西，生产者就会生产什么东西消费者通过它的货币选票引导生产者的生产它的引导机制是这样的：消费者用货币购买商品是向商品投“货币选票”，货币选票的投向和数量，取决于消费者对不同商品的偏好而生产者为了获得最大的利润，是依据货币选票的情况来按排生产，决定生产什么，生产多少、如何生产完全竞争市场供求相等的长期均衡表明，完全竞争的市场机制的运行是能够以最有效率的方式配置经济资源，从而使消费者得到最大满足所以它认为是消费决定生产，这就是消费者统治的说法  </li></ol></blockquote><h2 id="第七章-不完全竞争的市场"><a href="#第七章-不完全竞争的市场" class="headerlink" title="第七章 不完全竞争的市场"></a>第七章 不完全竞争的市场</h2><blockquote><p>不完全竞争市场是相对于完全竞争市场而说的，也就是说除了完全竞争市场以外，所有其它的市场或多或少都有一些垄断，所以我们称完全竞争市场以外的几种市场为不完全竞争市场不完全竞争市场分为三个类型：<strong>垄断市场，寡头市场、垄断竞争市场</strong></p></blockquote><h3 id="第一节-垄断"><a href="#第一节-垄断" class="headerlink" title="第一节 垄断"></a>第一节 垄断</h3><blockquote><ol><li>垄断市场的条件：垄断市场是指整个行业只有唯一的一个厂商的市场组织垄断市场的条件主要有这样三点：第一、市场上只有唯一的一个厂商生产和销售商品；第二，该厂商生产和销售的商品没有任何相近的替代品；第三，其它任何厂商进入该行业都非常困难或者不可能一个厂商控制了整个行业的生产和销售，所以它控制了市场的价格 </li><li>垄断形成的原因：第一，独家厂商控制了生产某种商品的全部资源或基本资源的供给排除了其它厂商生产同种商品的可能性第二、独家厂商拥有生产某处商品的专利权，使它在一个时期，垄断该产品的生产第三，政府的特许政府通过政策特许某个部门生产某种商品，不允许其它部门的界入第四，自然垄断 </li><li>垄断厂商的需求曲线：由于垄断行业中只有一个厂商，所以，垄断厂商所面临的需求曲线就是市场的需求曲线，它是一条向右下方倾斜的曲线我 </li><li>垄断厂商平均收益曲线：由于厂商的平均收益AR总是等于商品的价格P，所以，垄断厂商的AR曲线和需求曲线d重叠，都是同一条向右下倾斜的曲线 </li><li>垄断厂商的边际收益曲线：由于AR曲线是向右下方倾斜的，则根据平均量和边际量之间的相互关系可以推知，垄断厂商的边际收益MR总是小于平均收益AR因此，MR曲线位于AR曲线的左下方，且MR曲线也向右下倾斜 </li><li>垄断厂商的总收益曲线：每一销售量上的边际收益MR值就是相应的总收益TR曲线的斜率，所以当MR大于0时，总收益曲线的斜率为正，当MR小于0时，总收益曲线的斜率为负，当MR等于0时，总收益曲线达到最大值 </li><li>垄断厂商的短期均衡：垄断厂商的短期均衡也遵循MR=MC的原则，在短期内，垄断厂商无法改变不变要素的投入量，垄断厂商在既定的生产规模下通过对产量和价格的同时调整，来实现MR=SMC但是并不是说在MR=SMC时的短期均衡点，厂商总能获利，在该点，厂商有时获利，有时也亏损，但这时的亏损是最小的造成垄断厂商的亏损的原因，可能是既定的生产规模的成本过高（表现为相应的成本曲线的位置过高）也可能是垄断厂商所面临的市场需求过小，（表现为相应的需求曲线）所以，垄断厂商的短期均衡条件为：MR=SMC 垄断厂商的均衡点上可以获得最大利润，可以利润为0，也可以蒙受最小亏损 </li><li>厂商的供给曲线：在垄断市场的条件下，并不存在具有规律性的供给曲线因为在垄断竞争条件下，厂商既可以通过调节产量实现MR=SMC，又可以通过调节价格来实现MR=SMC价格和产量之间不存在一一对应的关系，可能是一个价格水平对应多个产量水平，也可能是一个产量水平对应多个价格水平因此在垄断市场条件下，无法得到如同完全竞争市场条件下的具有规律性的一一对应关系的厂商和行业的短期供给曲线 </li><li>垄断厂商的长期均衡：垄断厂商在长期内，通过调整生产规模，从而实现最大利润由于排除了其它企业的界入，所以在长期内它的利润可以保持垄断厂商的长期内对生产的调整一般可以有三种可能的结果：第一种，垄断厂商在短期内亏损，长期内又不存在一个可以使它获得利润的规模，那么该厂商退出该行业第二种结果，垄断厂商短期亏损，但长期内通过调整生产规模，摆脱了亏损的状态，甚至获得了利润第三种结果，短期盈利，长期通过调整生产规模，获得了更大的利润垄断厂商之所以能在长期内获得更大的利润，其原因在于长期内生产规模是可变的和市场对新加入厂商是完全关闭的在垄断厂商的MR=LMC的长期均衡产量上，代表最优生产规模的SAC曲线和LAC曲线相切，在均衡点上，SMC曲线与LMC曲线和MR曲线三者相交于一点，所以垄断厂商的长期均衡条件为：MR=LMC=SMC，垄断厂商在长期均衡点上获得了最大利润垄断厂商是市场上唯一的一个厂商，所以得出的垄断厂商的均衡价格与均衡产量就是垄断市场的均衡价格和均衡产量 </li><li>价格歧视：为了增加垄断厂商的利润，垄断厂商会对同一种产品收取不同的价格以不同价格销售同一种产品，被称为价格歧视垄断厂商实行价格歧视的基本条件：第一，市场的消费者具有不同的偏好，且这些不同的偏好可以被区分开这样，厂商才有可能对不同的消费者或消费群体收取不同的价格第二，不同的消费者群体或不同的销售市场是相互隔离的这样就排除了中间商从低价处买进商品，转手又在高价处出售商品从中获利的情况 价格歧视分为一级、二级和三级价格歧视 一级价格歧视：厂商对每一单位产品都按消费者所愿意支付的最高价格出售，又被称为完全价格歧视一级价格歧视下的资源配置是有效率的，尽管此时垄断厂商剥夺了全部的消费者剩余 二级价格歧视：二级价格歧视对不同的消费数量段制定不同的价格实行二级价格歧视，垄断厂商利润增加，部分消费者剩余被垄断者占有此外，垄断者有可能达到P=MC的有效率的资源配置的产量 三级价格歧视：垄断厂商对同一种产品在不同的市场上（或对不同的消费群）收取不同的价格，这就是三级价格歧视 </li><li>自然垄断和政府管制：自然垄断的一个主要特征是厂商的平均成本在很高的产量水平上仍然随着产量的增加而递减，也就是说存在着规模经济因为，这些行业的生产技术需求大量的固定设备，使得固定成本很大，而可变成本很小，所以，平均成本曲线在很高的产量水平上仍然是下降的一般地说，供电行业、供水行业、通讯行业都具有这样的特征 由于规模经济，所以，自然垄断的经济效果肯定比几家厂商同时经营时高但是，自然垄断由于缺乏竞争所造成垄断厂商的高价格、高利润以及低产出水平等经济效率的损失所以，在大多数西方国家，一些公用事业、通讯业和运输业都处于政府的管制之下 边际成本定价法：政府的管制价格应该等于边际成本按边际成本法决定的价格必定小于平均成本，在管制价格下，厂商是亏损的，厂商会退出生产这样一来，管制机构陷入了困境，要么放弃边际成本法，要么政府资助被套管制的企业  平均成本定价法：政府管制价格等于平均成本厂商不再亏损，厂商会继续经营，但利润为零 双重定价法类似于价格歧视法的做法具体说，允许厂商可以对一部分购买欲望强的消费者收取较高的价格，且P&gt;AC，从而厂商获得利润同时，厂商对一部分购买欲望较弱的消费者仍按边际成本定价法收取较低的价格，由于P&lt;AC，从而厂商是亏损的同时，双重定价法还要求制定的价格计划应该使厂商由于收取较高价格所获得的利润能补偿由于收取较低价格所遭受的亏损，这样，尽管从整体上看厂商利润为零，但厂商还是愿意继续经营的</li></ol></blockquote><h3 id="第二节-垄断竞争"><a href="#第二节-垄断竞争" class="headerlink" title="第二节 垄断竞争"></a>第二节 垄断竞争</h3><blockquote></blockquote><h3 id="第三节-寡头"><a href="#第三节-寡头" class="headerlink" title="第三节 寡头"></a>第三节 寡头</h3><blockquote><ol><li>寡头市场的特征：寡头市场又称为寡头垄断市场它是指少数几家厂商控制整个市场的产品的生产和销售这样一种市场组织它被认为是一种较为普遍的市场组织例如美国的汽车业、电气设备业、罐头行业等，都被几家企业所控制 </li><li>寡头市场形成的原因：某些产品的生产必须在相当大的生产规模上进行才能达到最好的经济效益；行业中几家企业对生产所需的基本生产资源的供给的控制；政论的扶植和支持等等寡头市场的成因与垄断市场的很相似的，只是程度有所差别而已寡头市场是比较接近垄断市场的一种市场组织 </li><li>寡头行业的分类：按产品特征，可以分为纯粹寡头行业和差别寡头行业两类纯粹寡头行业中，厂商之间生产的产品没有差别例如，钢铁、水泥行业差别寡头行业是指厂商之间生产的产品是有差别的，例如，汽车、冰箱行业按厂商的行动方式，区分为有勾结行为的（即合作的）和独立行动的（不合作的）两种类型 </li><li>寡头厂商的价格和产量的决定：这是一个很复杂的问题其主要原因在于：在寡头市场上，每个厂商的产量都在全行业的总产量中占一个较大的份额，每个厂商的价格和产量的变动都会都其它竞争对手以至整个行业的产量和价格产生举足轻重的影响所以，每个寡头厂商在采取某项行动之前，必须首先要推测或掌握自己这一行动对其他厂商的影响以及其它厂商可能作出的反应，根据所推测的反应采取最有利的行动寡头厂商们的行为之间的相互影响的复杂关系，使得寡头理论复杂化一般来说，不知道竞争对手的反应方式，就无法建立寡头厂商的模型或者说，有多少关于竞争对手的反应方式的假定，就有多少寡头厂商的模型，那么就有多少种不同的结果，因此，在西方经济学中，还没有一个寡头市场模型，可以对寡头市场的价格和产量的决定作出一般的理论总结 本节介绍两面个经典的寡头模型，它们是古诺模型和斯威齐模型这两个模型都属于独立行动条件下的寡头厂商模型 </li><li>古诺模型：古诺模型是由法国经济学家古诺于1838年提出的古诺模型是一个只有两个寡头厂商的简单模型，该模型也被称为“双头模型”古诺模型的结论很容易推广到三个或三个以上的寡头厂商的情况中去 古诺模型的假定是：市场上只有A、B两个厂商生产和销售相同的产品，它们的生产成本为零；它们共同面临的市场的需求曲线是线性的，A、B两个厂商都准确地了解市场的需求曲线；A、B两个厂商都是在已知对方产量的情况下，各自确定能够给自己带来最大利润的产量，即每一个厂商都是消极地以自己的产量去适应对方已确定的产量 古诺模型的结论：在均衡状态中，A、B两个厂商的产量都为市场总容量的1/3，即每个厂商的产量为1/3OQ，行业的总产量为2/3OQ 双头古诺模型的结论的推广：今寡头厂商的数量为M，则可以得到一般的结论：每个寡头厂商的均衡产量=1/（M+1）·市场容量 行业的均衡产量=M/（M+1）·市场容量 </li><li>斯威齐模型：这一模型用来解释寡头市场上的价格刚性现象价格刚性是指当成本有一定量的改变时价格却保持不变这就是说，在这种市场上，一旦价格决定之后，就有一定的相对稳定性这种情况在钢铁、汽车等寡头市场上存在斯威齐模型也被称为弯折的需求曲线该模型由美国经济学家斯威齐于是1939年提出的 斯威齐模型的基本假设条件是：如果一个寡头厂商提高价格，行业中的其它寡头厂商都不会跟着改变自己的价格，如果一个寡头厂商降低价格，行业中的其它寡头厂商会将价格下降到相同的水平，以避免销售份额的减少，因而该寡头厂商的销售量的增加是很有限的 斯威齐模型对出寡头厂商的弯折的需求曲线的推导：P242图7-16 有两条需求曲线dd需求曲线和DD需求曲线，dd需求曲线表示该寡头厂商变动价格而其它寡头厂商保持价格不变时该厂商的需求状况，DD需求曲线表示行业内所有寡头厂商都以相同方式改变时的该寡头厂商的需求状况假定开始时的市场价格为DD需求曲线与dd需求曲线的交点B所决定的价格P，那么根据该模型的假设条件，该垄断厂商由B点出发提价所面临的需求曲线为dd需求曲线上的dB段，降价所面临的需求曲线是DD需求曲线上的BD段，于是，这两段共同构成的该寡头厂商的需求曲线为Dbd很显然，这是一条弯折的需求曲线，折点是B点这条弯折的需求曲线表示该寡头厂商从B点出发，在各个价格水平所面临的市场需求量由弯折的需求曲线可以得到间断的边际收益曲线 斯威齐模型对价格刚性的解释：用间断的边际收益曲线，可以解释寡头市场上的价格刚性现象根据边际收益等于边际成本决定厂商的均衡产量和均衡价格在边际收益的垂直间断范围内随着边际成本的上升，那么它的均衡价格和均衡产量不发生变化也就是说这时的价格是有刚性的只有成本发生很大的变化，才会影响均衡价格和均衡产量 斯威齐模型的缺陷：斯威齐模型也就是弯折的需求曲线解释了寡头市场较为普遍的价格刚性形成的原因，但是该模型并没有说明具有刚性的价格本身，如图中的价格水平P，是如何形成的，这是该模型的一个缺陷 </li><li>寡头厂商的供给曲线：如同垄断厂商和垄断竞争厂商一样，寡头厂商的需求曲线也是向右下方倾斜的，寡头厂商的均衡产量和均衡价格之间也不存在一一对应的关系，同时由于寡头厂商之间的行为相互作用的复杂性，所以，不存在寡头厂商和行业的具有规律性的供给曲线</li></ol></blockquote><h3 id="第四节-寡头厂商之间的博弈：博弈论初步"><a href="#第四节-寡头厂商之间的博弈：博弈论初步" class="headerlink" title="第四节 寡头厂商之间的博弈：博弈论初步"></a>第四节 寡头厂商之间的博弈：博弈论初步</h3><blockquote><p>博弈论是描述和研究行为者之间策略相互依存和相互作用的一种决策理论 </p><ol><li><p>博弈论的基本要素：参与者，策略，支付 </p></li><li><p>博弈均衡的基本概念： </p><ul><li><p>占优策略：无论其他参与者采取什么策略，某参与者的惟一的最优策略就是他的占优策略 </p></li><li><p>博弈均衡：博弈中的所有参与者都不想改变自己的策略这样一种状态 </p></li><li><p>占优策略均衡：由博弈中的所有参与者的占优策略组合所构成的均衡就占优策略均衡 </p></li><li><p>纳什均衡：在一个纳什均衡里，任何一个参与者都不会改变自己的策略，如果其他参与者不改变策略占优策略均衡是比纳什均衡更强的一个博弈均衡概念占优策略均衡要求任何一个参与者对于其他参与者的任何策略来说，其最优策略是惟一的而纳什均衡只要求任何一个参与者在其他参与者的策略选择给定的条件下，其选择的策略是最优的所以占优策略均衡一定是纳什均衡，而纳什均衡不一定是占优策略均衡</p></li></ul></li></ol><ol start="3"><li><p>寡头厂商的共谋及其特征 囚犯的困境：关于寡头厂商之间合作与不合作的策略选择的博弈分析，属于“囚犯的困境”的博弈类型假设甲、乙二人被怀疑为合谋偷窃的嫌疑犯，警方把他们抓获了，但是证据不足，所以对他们进行单独审讯给两个嫌疑犯交待的量刑原则是：P275图7-19 那么这两个囚犯的博弈过程是这样的，如果两个人都不坦白即合作抵赖，则都可以获得最好的结局但是由于他们无法建立攻守同盟，所以每一方都担心对方坦白而自己不坦白时所要遭受的重判，所以，每个囚犯的占优策略都是坦白，即双方不合作，于是，（坦白，坦白）便是该博弈的占优策略均衡 囚犯的困境反映了一个问题，从个人角度出发所选择的占优策略，从整体来看，却是最差的结局即个人理性和团体理性的冲突 重复博弈：前面所分析的博弈都是一次性的，即每个参与者只参加一次策略的选择，一旦策略选定，整个博弈的结局也就决定了，参与者不能博弈的过程施加什么影响这类博弈被称为静态博弈动态博弈是一种反复进行的博弈，也就是说同一个博弈被套重复多次在一次博弈过程中，由于任何违约行为都不会遭受报复，囚犯困境的不合作是难以避免的在重复博弈中，对于任何一个参与者的违约行为，成员之间都采取“以牙还牙”的策略，所以对于无限期限的重复博弈，囚犯困境合作的均衡解是存在的也就是说合作的状态会持续下去 </p></li><li><p>威胁和承诺的可信性：寡头厂商为实现自己的目标，有时会对竞争对手采取威胁或承诺的策略但只有其威胁或承诺可信时，策略才会奏效 </p></li></ol></blockquote><h3 id="第五节-不同市场的比较"><a href="#第五节-不同市场的比较" class="headerlink" title="第五节 不同市场的比较"></a>第五节 不同市场的比较</h3><blockquote><ol><li>经济效率：是指利用经济资源的有效性 </li><li>配置效率（效率）：在资源和技术既定的条件下，如果该经济组织能够为消费者提供最大可能的各种物品和劳务的组合，那么，这个经济就是有效率的市场组织的类型直接影响经济效率的高低效率不仅仅仅要求所生产商品的正确组合，它还需要这些商品在分配给消费者时，使消费者满足程度最大化我们根据这个标准通过比较不同市场组织条件下长期均衡点来分析哪一种市场组织的效率最大 </li><li>经济效率的比较：在完全竞争条件下，均衡点在长期平均成本的最低点，而且水平的需求曲线相切于LAC的最低点在长期均衡点P=LAC，利润为0在完全竞争市场条件下，产品的均衡价格最低，它等于最低的生产平均成本；产品的均衡产量最高 在不完全竞争条件下，竞争程度越高，长期均衡时的均衡价格越低，均衡产量越高，它的经济效率越高；垄断程度越高，长期均衡时的均衡价格越高，均衡产量越低，经济效率越低 另外，西方经济学家认为，一个行业在长期均衡时是否实现了P=LMC，也是判断该行业是否实现了有效的资源配置的一个条件如果P&gt;LMC，那么说明商品的供给不足的，应该有更多的资源转移到该商品的生产中来，以使这种商品的供给增加，价格下降，以使消费者的效用达到最大化，社会境况变得更好一些在完全竞争市场，P=LMC，它表明资源得到了有效的配置在不完全竞争市场，有P&gt;LMC，它表明资源在该行业的配置是不足的尤其是在垄断市场，独家厂商维持了高价低产，资源配置不足的现象更为突出 由此得出，市场的竞争程度越高，则经济效率越高；反之，垄断程度越高，则经济效率越低所以，完全竞争市场的经济效率是最高的，垄断竞争较高，寡头市场较低，垄断市场最低  </li></ol></blockquote><h2 id="第八章-生产要素价格决定的需求方面"><a href="#第八章-生产要素价格决定的需求方面" class="headerlink" title="第八章 生产要素价格决定的需求方面"></a>第八章 生产要素价格决定的需求方面</h2><h3 id="第一节-分配论概述"><a href="#第一节-分配论概述" class="headerlink" title="第一节 分配论概述"></a>第一节 分配论概述</h3><blockquote><ol><li>生产要素与要素价格：生产要素包括土地、劳动、资本和企业家才能四种，相应的要素价格分别被称为地租、工资、利息和利润 </li><li>边际生产率分配论：该理论认为，其他条件不变，一种要素的价格取决于其边际生产力以完全竞争厂商为例，厂商要想实现利润的最大化，其最优的劳动使用量必须满足VMPL=P·MPL=W的条件，故有W/P=MPL，即工人的实际工资最终取决于劳动的边际产量同理可以得到，资本和土地的价格也取决于其边际产量的多寡因此，看上去，每一种生产要素都得到了各自对生产所作出的贡献（各自的边际生产率）作为报酬  </li></ol></blockquote><h3 id="第二节-引致需求"><a href="#第二节-引致需求" class="headerlink" title="第二节 引致需求"></a>第二节 引致需求</h3><blockquote><ol><li>引致需求：与对产品的需求不同，要素需求是一种引致的需求 </li><li>生产要素需求的“共同性”：即对生产要素的需求是共同的、相互依赖的需求 </li></ol></blockquote><h3 id="第三节-完全竞争厂商使用生产要素的原则"><a href="#第三节-完全竞争厂商使用生产要素的原则" class="headerlink" title="第三节 完全竞争厂商使用生产要素的原则"></a>第三节 完全竞争厂商使用生产要素的原则</h3><blockquote><ol><li><p>完全竞争厂商 完全竞争厂商：完全竞争厂商无论在产品市场还是在要素市场都是一个完全竞争者 不完全竞争厂商的类型：</p><p>（1）在产品市场上完全竞争，在要素市场上不完全竞争；</p><p>（2）在产品市场上不完全竞争，在要素市场上完全竞争；</p><p>（3）在产品市场上不完全竞争，在要素市场上不完全竞争 </p></li><li><p>完全竞争厂商使用要素的原则 使用要素的边际收益—边际产品价值：VMP=MP·P 使用要素的边际成本—要素价格：dC(L)/dL=W 完全竞争厂商使用要素的原则：VMP=W或MP·P=W 为实现利润最大化的目标，厂商必须在要素的边际收益和要素的边际成本相等的地方 确定其要素需求量就完全竞争厂商来讲，其要素使用原则可表示为VMP=W，这里的VMP可以是任一种要素的边际收益即边际产品价值，W则为相应要素的市场价格（就卖方垄断厂商而言，要素使用原则可表示为MRP=W；而买方垄断厂商的使用原则则可表示为VMP=MFC虽然形式不同，其实质都是一样的）</p></li></ol></blockquote><h3 id="第四节-完全竞争厂商对生产要素的需求曲线"><a href="#第四节-完全竞争厂商对生产要素的需求曲线" class="headerlink" title="第四节 完全竞争厂商对生产要素的需求曲线"></a>第四节 完全竞争厂商对生产要素的需求曲线</h3><blockquote><p>若生产中只使用一种要素L，则单个完全竞争厂商关于该要素的需求曲线就是其边际产品价值曲线 </p></blockquote><h3 id="第五节-从厂商的需求曲线到市场的需求曲线"><a href="#第五节-从厂商的需求曲线到市场的需求曲线" class="headerlink" title="第五节 从厂商的需求曲线到市场的需求曲线"></a>第五节 从厂商的需求曲线到市场的需求曲线</h3><blockquote><p>要素需求曲线的推导：与第三章我们在由个别需求曲线导出市场需求曲线时的做法类似，这里也可用水平加总的办法以由个别厂商的要素需求曲线得到市场的要素需求曲线但考虑到不同厂商的行为的相关性（当所有厂商根据要素价格的变化同时调整其要素需求量时，它们的VMP线不是相互独立的），市场的要素需求曲线不能直接由各厂商的VMP线水平相加得到须先对个别厂商的VMP作调整得到行业调整线，然后再水平相加因此，考虑到所有厂商的同时调整，单个厂商的要素需求曲线不再是其边际产品价值线，而是一条更为陡峭的行业调整线将厂商的行业调整线水平加总，即得完全竞争市场的要素需求曲线  第六节卖方垄断对生产要素的使用原则 卖方垄断厂商的特点：产品市场上的垄断者和要素市场上的完全竞争者 卖方垄断厂商使用要素的边际收益：MRP=MR·MP 卖方垄断厂商使用要素的原则：MRP=W或MR·MP=W </p></blockquote><h3 id="第七节-卖方垄断对生产要素的需求曲线"><a href="#第七节-卖方垄断对生产要素的需求曲线" class="headerlink" title="第七节 卖方垄断对生产要素的需求曲线"></a>第七节 卖方垄断对生产要素的需求曲线</h3><blockquote><p>如果假定只使用一种要素，则无论是否考虑多个厂商的调整，卖方垄断厂商的要素需求曲线都等于其边际收益产品曲线MRP 若所有厂商均为买方垄断者，则市场的要素需求曲线可由所有厂商的边际收益产品曲线水平相加得到 </p></blockquote><h3 id="第八节-买方垄断情况下生产要素的价格和数量的决定"><a href="#第八节-买方垄断情况下生产要素的价格和数量的决定" class="headerlink" title="第八节 买方垄断情况下生产要素的价格和数量的决定"></a>第八节 买方垄断情况下生产要素的价格和数量的决定</h3><blockquote><p>买方垄断：要素市场上的垄断者和产品市场上的完全竞争者 买方垄断的要素供给函数与边际要素成本： W(L)=a+bL(a,b均为常数，且b&gt;0) MFC=a+2bL </p><p>买方垄断厂商的要素使用原则： VMP=MFC </p><p>买方垄断厂商的要素需求曲线：不存在  </p></blockquote><h2 id="第九章-生产要素价格决定的供给方面"><a href="#第九章-生产要素价格决定的供给方面" class="headerlink" title="第九章 生产要素价格决定的供给方面"></a>第九章 生产要素价格决定的供给方面</h2><h3 id="第一节-对供给方面的概述"><a href="#第一节-对供给方面的概述" class="headerlink" title="第一节 对供给方面的概述"></a>第一节 对供给方面的概述</h3><blockquote><ol><li>要素供给及要素供给者要素供给指在各种价格水平下，生产要素所有者愿意并且能够提供的生产要素的数量要素供给者既包括生产者也包括消费者，生产者是中间要素的提供者，消费者是原始要素的提供者对中间要素的供给要根据生产者利润最大化的行为来讨论，对原始要素的供给要根据消费者效用最大化的行为来讨论其中前者与一般产品的供给一样已经学过，所以本章主要探讨的是后者，即从消费者的效用最大化行为出发来建立要素供给量与要素价格之间的关系 </li><li>要素供给的原则即消费者效用水平最大化的条件可以从两个方面得出结论，以基数效用论为基础得出的条件是：要素供给的边际效用等于自用资源的边际效用，在完全竞争条件下公式为：W·dU/dY=dU/dし，即W=MUし/MUY；在非完全竞争下公式为：dU/dY·dY/dL=dU/dし，即MUし/MUY=dY/dL以序数效用论为基础得出的条件是：无差异曲线的斜率等于预算线的斜率，即dY/dし=-W </li><li>要素供给曲线生产要素的供给表现为各种要素所有者在不同要素价格下愿意而且能够供给的要素数量生产要素供给曲线反映的是要素供给量与要素价格之间的关系它是由价格扩展线推导而来的要素供给曲线的形状，一般是向右上方倾斜的，也可以是垂直的或向右下方倾斜的，其形状究竟如何取决于消费者效用函数的特点</li></ol></blockquote><h3 id="第二节-劳动供给曲线和工资率的决定"><a href="#第二节-劳动供给曲线和工资率的决定" class="headerlink" title="第二节 劳动供给曲线和工资率的决定"></a>第二节 劳动供给曲线和工资率的决定</h3><blockquote><ol><li>劳动供给曲线劳动供给问题是消费者如何决定其全部资源在闲暇和劳动供给两种用途上的分配问题劳动供给曲线反映的是劳动要素供给量与其价格（工资）之间的关系与一般供给曲线不同，单个消费者的劳动供给曲线有一段“向后弯曲”的部分：当工资较低时，随着工资的上升，消费者为较高的工资吸引将增加劳动供给量，这时，劳动供给曲线同一般供给曲线一样向右上方倾斜；当工资增加到一定程度后，再增加工资，劳动供给量会减少，这时，劳动供给曲线开始向后弯曲将所有单个消费者的劳动供给曲线水平相加，可以得到市场的劳动供给曲线，它同一般的供给曲线一样，是向右上方倾斜的 </li><li>劳动供给曲线向后弯曲的原因经济学上用闲暇的需求曲线来说明劳动供给曲线的形状由于替代效应，闲暇需求量与闲暇价格反方向变化；由于收入效应，闲暇需求量与闲暇价格同方向变化且收入效应大于替代效应，因此导致闲暇需求量与闲暇价格的变化方向相同，需求曲线向前上斜，于是劳动供给曲线在较高的工资水平上开始向后弯曲 </li><li>均衡工资的决定向右下方倾斜的劳动的市场需求曲线和向右上方倾斜的劳动的市场供给曲线的交点即是劳动市场的均衡点，该均衡点决定了劳动的均衡工资和均衡数量因此，均衡工资水平由劳动市场的供求曲线决定 </li></ol></blockquote><h3 id="第三节-土地的供给曲线和地租的决定"><a href="#第三节-土地的供给曲线和地租的决定" class="headerlink" title="第三节 土地的供给曲线和地租的决定"></a>第三节 土地的供给曲线和地租的决定</h3><blockquote><ol><li>土地供给曲线土地供给问题是土地所有者如何将既定数量的土地资源在保留自用和供给市场两种用途上进行分配以获得最大效用的的问题假定土地只有供给市场的一种用途，而没有自用用途，则土地供给曲线是垂直的这个结论不仅适用于土地，而且也适用于任何其他要素 </li><li>地租的决定向右下方倾斜的土地的市场需求曲线和土地供给曲线结合起来，即可决定土地的均衡价格当土地的市场供给曲线是垂直线时，它与土地需求曲线的交点所决定的土地服务价格为地租 </li><li>租金、准租金和经济租金租金是一般化的地租，指供给数量不变的一般资源的服务价格准租金是对供给量暂时固定的生产要素的支付，即固定生产要素的收益，它是固定总成本与经济利润之和如果从要素收入中减去一部分收入后并不影响要素供给，则这部分要素收入就是经济租金，它的几何解释类似于生产者剩余，是要素价格以下、要素供给曲线以上的区域  </li></ol></blockquote><h3 id="第四节-资本的供给曲线和利息的决定"><a href="#第四节-资本的供给曲线和利息的决定" class="headerlink" title="第四节 资本的供给曲线和利息的决定"></a>第四节 资本的供给曲线和利息的决定</h3><blockquote><ol><li>资本供给曲线资本供给问题同土地和劳动的供给问题一样，涉及的是既定资本资源如何在资本供给和自用两种用途之间的分配问题如果假定资本的自用价值等于零，则既定资本资源的供给也是固定的，其供给曲线为一条垂直线 </li><li>最优资本拥有量（长期消费决策）由于资本数量是可变的，所以资本供给问题不单单是最优资本量的供给问题，还有如何确定最优的资本拥有量的问题最优资本拥有量问题实际上就是确定最优储蓄量的问题，可以归结为既定收入在消费和储蓄之间进行分配的问题，也可以看成是在现在消费和未来消费之间进行选择的问题这就是消费者的长期消费决策问题由消费者的长期消费决策可以推导出其储蓄或贷款供给曲线，也就是最优资本拥有曲线，它反映的是利率与最优资本拥有量之间的关系，其形状与劳动供给曲线相同：随着利率的上升，人们的储蓄会增加，曲线向右上方倾斜；当利率很高时，曲线又出现向后弯曲的现象 </li><li>利息的决定资本的市场需求曲线同商品的需求曲线一样，也是向右下方倾斜的；资本要素的供给曲线是垂直的把资本的市场需求曲线与市场供给曲线综合起来，二者的交点处所决定的即为资本的服务价格利息</li></ol></blockquote><h3 id="第五节-欧拉定理"><a href="#第五节-欧拉定理" class="headerlink" title="第五节 欧拉定理"></a>第五节 欧拉定理</h3><blockquote><p>欧拉定理（产量分配净尽定理）指在完全竞争条件下，如果规模报酬不变，则全部产品正好足够分配给各个生产要素，不多也不少假如社会只使用劳动和资本两种生产要素，则Q=L·MPL+K·MPK欧拉定理只有在规模报酬不变的条件下才是适用的在规模报酬递增的情况下，产量会不够分配给各个生产要素，即QL·MPL+K·MPK </p></blockquote><h3 id="第六节-洛伦兹曲线和基尼系数"><a href="#第六节-洛伦兹曲线和基尼系数" class="headerlink" title="第六节 洛伦兹曲线和基尼系数"></a>第六节 洛伦兹曲线和基尼系数</h3><blockquote><p>洛伦兹曲线和基尼系数它们均是反映收入分配的不平等程度的洛伦兹曲线是人口累计百分比和收入累计百分比对应关系的几何图形，其弯曲程度越大，收入分配越不平等；弯曲程度越小，收入分配越平等若洛伦兹曲线与绝对平等线（450线）之间的面积为“不平等面积”A，洛伦兹曲线与绝对不平等线之间的面积为B，A+B为“完全不平等面积”，则不平等面积与完全不平等面积之比就是基尼系数，即G=A/（A+B）基尼系数越大，收入分配越不平等；反之亦然  </p></blockquote><h2 id="第十章-一般均衡论和福利经济学"><a href="#第十章-一般均衡论和福利经济学" class="headerlink" title="第十章 一般均衡论和福利经济学"></a>第十章 一般均衡论和福利经济学</h2><h3 id="第一节-一般均衡"><a href="#第一节-一般均衡" class="headerlink" title="第一节 一般均衡"></a>第一节 一般均衡</h3><blockquote><ol><li>局部均衡和一般均衡：局部均衡主要是分析研究单个产品或要素市场（是把所考虑的某个市场从相互联系的构成整个经济体系的市场全体中“取出”来单独加以研究），该市场商品的需求和供给仅仅被看成是其本身价格的函数，其他商品的价格则被假定为不变，而这些不变价格的高低只影响所研究商品的供求曲线的位置，这样该市场的需求和供给曲线共同决定了市场的均衡价格和均衡数量一般均衡是将所有相互联系的各个市场看成一个整体来加以研究，每一商品的供给和需求不仅取决于该商品本身的价格，而且也取决于所有其他商品（如替代品和互补品）的价格每一商品的价格都不能单独的决定，而必须和其他商品价格联合着决定只有当整个经济的价格体系恰好是所有的商品都供求相等时，市场才达到一般均衡 </li><li>一般均衡的存在性：存在一组价格，使得所有市场的供给和需求都恰好相等，即存在着整个经济体系的一般均衡 </li><li>实现一般均衡的“试探”过程  </li></ol></blockquote><h3 id="第二节-经济效率"><a href="#第二节-经济效率" class="headerlink" title="第二节 经济效率"></a>第二节 经济效率</h3><blockquote><ol><li><p>实证经济学和规范经济学：实证经济学研究实际经济体系是怎样运行的，它对经济行为作出有关的假设，根据假设分析和陈述经济行为及其后果，并试图对结论进行检验简言之，实证经济学回答“是什么”的问题规范经济学试图从一定的社会价值判断标准出发，根据这些标准，对一个经济体系的运行进行评价，并进一步说明一个经济体系应当怎样运行，以及为此提出相应的经济政策简言之，规范经济学回答“应当是什么”的问题 福利经济学是在一定的社会价值判断标准条件下，研究整个经济的资源配置与个人福利的关系，以及与此有关的各种政策问题换句话说，福利经济学研究要素在不同厂商之间的最优分配以及产品在不同家户之间的最优分配，即研究资源的最优配置福利经济学属于规范经济学的范畴 </p></li><li><p>判断经济效率的标准 帕累托最优状态标准：多人社会在多种资源配置状态中进行选择，其中A与B是任意两种状态，如果至少有一人认为A优于B，而没有人认为A劣于B，则认为从社会的观点看亦有A优于B这就是所谓的帕累托最优状态标准，简称帕累托标准</p><p>帕累托改进：如果既定的资源配置状态的改变使得至少有一个人的状况变好，而没有使任何人的状况变坏，则认为这种资源配置状态的变化是“好”的，这种以帕累托标准来衡量为“好”的状态改变称为帕累托改进 </p><p>帕累托最优状态：如果对于某种既定的资源配置状态，所有的帕累托改进均不存在，即在该状态上，任意改变都不可能使至少有一个人的状况变好而又不使任何人的状况变坏，则称这种资源配置状态为帕累托最优状态帕累托最优状态又称做经济效率 </p></li></ol></blockquote><h3 id="第三节-交换的帕累托最优条件"><a href="#第三节-交换的帕累托最优条件" class="headerlink" title="第三节 交换的帕累托最优条件"></a>第三节 交换的帕累托最优条件</h3><blockquote><p>要使两种商品X和Y在两个消费者A和B之间的分配达到帕累托最优状态，则对于这两个消费者来说，这两种商品的边际替代率必须相等 </p><p>交换的帕累托最优状态条件的公式：MRSAXY=MRSBXY </p></blockquote><h3 id="第四节-生产的帕累托最优条件"><a href="#第四节-生产的帕累托最优条件" class="headerlink" title="第四节 生产的帕累托最优条件"></a>第四节 生产的帕累托最优条件</h3><blockquote><p>要使两种生产要素L和K在两个生产者C和D之间的分配达到帕累托最优状态，则对于这两个生产者来说，这两种生产要素的边际技术替代率必须相等 生产的帕累托最优状态条件的公式：MRTSCLK=MRTSDLK</p></blockquote><h3 id="第五节-交换和生产的帕累托最优条件"><a href="#第五节-交换和生产的帕累托最优条件" class="headerlink" title="第五节 交换和生产的帕累托最优条件"></a>第五节 交换和生产的帕累托最优条件</h3><blockquote><p>交换和生产的帕累托最优状态条件的公式：MRTXY=MRSXY即两种产品的边际替代率等于边际转换率 </p></blockquote><h3 id="第六节-完全竞争和帕累托最优状态"><a href="#第六节-完全竞争和帕累托最优状态" class="headerlink" title="第六节 完全竞争和帕累托最优状态"></a>第六节 完全竞争和帕累托最优状态</h3><blockquote><p>本章还讨论了完全竞争一般均衡状态和帕累托最优状态的关系在完全竞争经济中消费者追求效用最大化的条件为：MRSAXY=PX/PY，MRSBXY=PX/PY，A、B为任意两消费者，X、Y为任意两产品于是得到：MRSAXY=MRSBXY因此，产品的均衡价格实现了交换的帕累托最优状态在完全竞争经济中生产者追求利润最大化的条件为：MRTSCLK=PL/PK，MRTSDLK=PL/PK，C、D为任意两生产者，L、K为任意两生产要素于是得到：MRTSCLK=MRTSDLK因此，要素的均衡价格实现了生产的帕累托最优状态在完全竞争条件下，MRTXY=│△Y/△X│=MCX/MCY，MCX/MCY=PX/PY，MRSAXY=PX/PY，于是得到：MRTXY=PX/PY=MRSXY因此，商品的均衡价格实现了生产和交换的帕累托最优状态在完全竞争经济中消费者和生产者的最优化行为可以使帕累托最优的三个必要条件得到满足完全竞争的市场机制作用下，整个经济可以实现帕累托最优状态，这样的经济必定是最有效率的经济 </p></blockquote><h3 id="第七节-社会福利函数"><a href="#第七节-社会福利函数" class="headerlink" title="第七节 社会福利函数"></a>第七节 社会福利函数</h3><blockquote><ol><li>社会福利函数：社会福利函数是社会所有个人的效用水平的函数在两人社会中可以写成：W=W（UA，UB）由社会福利函数可以得到社会无差异曲线社会无差异曲线与效用可能性曲线的切点代表了可能达到最大社会福利 </li><li>阿罗不可能性定理：在非独裁的情况下，不可能存在有适用于所有个人偏好的社会福利函数，这就是所谓的阿罗不可能性定理阿罗不可能性定理表明不存在一种把个人偏好加总为社会偏好的理想方法</li></ol></blockquote><h3 id="第八节-效率与公平"><a href="#第八节-效率与公平" class="headerlink" title="第八节 效率与公平"></a>第八节 效率与公平</h3><blockquote><ol><li>效率与公平的矛盾：效率的提高并不能够自然而然地改善收入的分配；增进公平的 政策可能会损害效率 </li><li>“效率优先”与“兼顾公平”：这是解决效率与公平矛盾的较为普遍的一个思路 </li><li>收入再分配的具体措施：通过税收、政府支出以及其他一些措施，政府能够在一定程度上改善分配公平问题 </li></ol></blockquote><h2 id="第十一章-市场失灵和微观经济政策"><a href="#第十一章-市场失灵和微观经济政策" class="headerlink" title="第十一章 市场失灵和微观经济政策"></a>第十一章 市场失灵和微观经济政策</h2><h3 id="第一节-垄断-1"><a href="#第一节-垄断-1" class="headerlink" title="第一节 垄断"></a>第一节 垄断</h3><blockquote><ol><li>垄断与低效率：垄断厂商利润最大化原则是边际成本等于边际收益，垄断厂商获得超额经济利润，此时确定的价格大于边际成本，资源配置偏离帕累托最优状态，整个经济均衡于低效率之中图12-1中△GIH所代表的面积就是由于垄断所引起的社会福利的纯损失，它表示由于垄断所造成的低效率而带来的经济损失 </li><li>寻租理论：垄断还可造成更大的经济损失，为了获得和维持垄断地位从而获取超额经济利润，厂商常常付出一定代价，这种行为是一种纯粹的浪费，它不是用于生产，没有创造出任何有益的产出，完全是一种非生产性的寻利活动，一般称其为“寻租” </li><li>公共管制：公共管制一般是指政府对垄断的干预，即并非由垄断企业自行确定产品的价格和产量，而是由政府管制，包括有边际成本定价法、平均成本定价法、双重定价法以及资本回报率管制 4反托拉斯法：政府反对垄断的法律规定反托拉斯法规定，限制贸易的协议或共谋、垄断或企图垄断市场、兼并、排他性规定、价格歧视、不正当的竞争或欺诈行为等，都是违法的，对违法者可以由法院提出警告、罚款、改组公司直至判刑 </li></ol></blockquote><h3 id="第二节-外部影响"><a href="#第二节-外部影响" class="headerlink" title="第二节 外部影响"></a>第二节 外部影响</h3><blockquote><ol><li>外部影响：外部影响是指某经济行为所产生的私人成本和私人利益与该行为所产生的社会成本和社会利益不相等 </li><li>外部影响分类：经济行为所产生的私人利益小于社会利益称为外部经济，经济行为所产生的私人成本小于社会成本称为外部不经济，具体又可分类为生产的外部经济、消费的外部经济、生产的外部不经济和消费的外部不经济 </li><li>外部影响与资源配置失当：外部影响的存在造成完全竞争条件下的资源配置偏离帕累托最优状态外部经济的情况下，私人利益小于社会利益，私人活动水平低于社会所要求的最优水平外部不经济的情况下，私人成本小于社会成本，私人活动水平高于社会所要求的最优水平 </li><li>解决外部性问题的途径：⑴使用税收和津贴对外部不经济的行为，进行征税或罚款，对外部经济的行为予以津贴或奖励⑵使用企业合并的方法不同的企业合并，可使外部影响内部消化⑶使用规定财产权的办法 </li><li>科斯定理：只要财产权是明确的，并且其交易成本为零或者很小，则无论在开始时将财产权赋予谁，市场均衡的最终结果都是有效率的 </li></ol></blockquote><h3 id="第三节-公共物品"><a href="#第三节-公共物品" class="headerlink" title="第三节 公共物品"></a>第三节 公共物品</h3><blockquote><ol><li>排他性和竞用性：私人物品与公共物品的不同在于后者的排他性和竞用性通常将不具备消费的排他性和竞用性的商品叫做公共物品，而把海鱼这一类只不具有排他性但却具有竞用型的物品叫做公共资源 </li><li>公共物品与市场失灵：公共物品具有非竞争性，增加一名消费者的消费，其边际成本为零，公共物品具有非排他性，很容易产生免费搭车问题公共物品如果由竞争市场上私人进行生产，其结果只能是低于社会所要求最优数量的产出，甚至是零产出 </li><li>公共物品解决办法：公共物品由政府或公共部门安排生产并根据社会福利原则来分配公共物品 </li><li>公共资源：公地悲剧的发生与寓意 </li><li>公共物品生产的调节机制：⑴成本—收益分析成本—收益分析是对某公共投资带来的现值给予估计，然后同它预期所需支出的成本相比较，以求出该项计划可能产生的全部收益与全部成本的比率，根据评估结果看该项目是否值得生产⑵公共选择理论公共选择理论用经济学的方法来分析、研究政府对供给品的决策，特别注重研究那些与政府行为有关的集体选择问题</li></ol></blockquote><p>第四节不完全信息 </p><blockquote><ol><li>不完全信息：完全竞争模型的一个重要假定是完全信息，即市场的供求双方对于所交换的商品具有充分的信息在现实经济中，信息常常是很不完全的信息不完全不仅是指那种绝对意义上的不完全，即由于认识能力的限制，人们不可能知道在任何时候、任何地方发生的或将要发生的任何情况，而且是相对意义上的不完全，即市场经济本身不能够生产出足够的信息并有效地配置它们 </li><li>信息不完全与商品市场：商品市场上信息少的一方与信息多的一方做交易时，信息少的一方面对交易对手做逆向选择，逆向选择可导致效率损失 </li><li>信息不完全与保险市场：保险市场上表现为保险公司的信息不完全，常发生道德风险，即交易的一方无法观察到另一方所采取的行动，由此发生的具有私人信息或信息优势的一方故意不采取谨慎行动的情况 </li><li>信息不完全与劳动市场：劳动市场上典型特点是招聘者的信息不完全而导致经济的低效率 </li><li>信息不完全和激励机制：委托-代理问题：委托人必须设计合理有效的激励，以使代理人的行为与委托人的利益相一致 </li><li>信誉和信息调控：通过建立“信誉”以及政府在信息方面进行调控，可以有效解决信息不充分问题</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>微观经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管理系统回顾</title>
    <link href="/2020/04/13/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9B%9E%E9%A1%BE/"/>
    <url>/2020/04/13/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="全栈管理系统学习回顾"><a href="#全栈管理系统学习回顾" class="headerlink" title="全栈管理系统学习回顾"></a>全栈管理系统学习回顾</h1><ul><li><p>创建项目文件夹，终端<code>npm init</code></p></li><li><p>创建后端入口文件<code>server.js</code></p></li><li><p>安装<code>express</code></p></li><li><p>引入<code>express</code></p><ul><li><pre><code>const express = require(&#39;express&#39;)const app = express()//设置路由app.get(&#39;/&#39;,(req,res) =&gt; {    res.send(&#39;hello&#39;)})//设置端口const port = process.env.PORT ||3000app.listen(port,() =&gt; {console.log(`server running on port ${port}`)})</code></pre></li></ul></li><li><p>安装<code>nodemon</code></p><ul><li><p>配置<code>nodemon</code></p></li><li><pre><code>package.json{&quot;script&quot;: {    &quot;start&quot;: &quot;node server.js&quot;    &quot;server&quot;: &quot;nodemon server.js&quot;}}现在可以npm run server 启动了，会自动保存</code></pre></li></ul></li><li><p><code>mongodb</code></p><ul><li><p>安装本地<code>mongodb</code>创建一个collection</p></li><li><p>安装<code>mongoose</code>导入<code>mongoose</code></p></li></ul><ul><li><pre><code>//创建配置文件module.exports = {    mongoURI:&quot;mongodb://用户名:密码@localhost:27017/数据库名&quot;}</code></pre></li><li><pre><code>//导入配置const db = require(&#39;./config/keys&#39;).mongoURI//连接数据库mongoose.connect(db)                .then(() =&gt; console.log(&#39;mongodb connected&#39;))                .catch(err =&gt; console.log(err)</code></pre></li></ul><ul><li><pre><code>//模型//model/User.jsconst mongoose = require(&#39;mongoose&#39;)const Schema = mongoose.Schema//create Schemaconst UserSchema = new Schema({    name:{    type:String,    required:true    },    ···})module.exports = User = mongoose.model(&#39;users&#39;,UserSchema)</code></pre></li><li></li></ul></li><li><p>接口部分</p><ul><li><p>创建<code>routes/api</code>文件夹</p></li><li><pre><code>//users.js 用户接口const express = require(&#39;express&#39;)const router = express.Router()//$route GET api/users/test//@desc 返回的请求的json数据//@acess publicrouter.get(&#39;/test&#39;,(req,res) =&gt; {    res.json({msg: &#39;login work&#39;})})module.exports=router</code></pre></li><li><pre><code>//引入路由文件用中间件使用他app.use(&#39;/users&#39;,users)</code></pre></li></ul><ul><li><p>post请求获取参数必须使用第三方模块<code>bodyparser</code></p><pre><code>//引入bodyparser//使用中间件app.use(bodyparser.urlencoded({extended: false}))app.use(bodyparser.json())</code></pre></li><li><p>查询邮箱是否存在</p><pre><code class="javascript">User.findOne({email:req.body.email})        .then((user)=&gt;{            if(user){                return res.status(400).json(&#39;邮箱已存在&#39;)            }else{                const newUser = new User({                    name: req.body.name,                    email: req.body.email,                    password: rea.body.password                })                bcrypt.genSalt(saltRounds,(err,salt)=&gt;{            bcrypt.hash(myPlaintexPassword,salt,(err,hash)=&gt;{              //saltRounds,模式什么的吧填10就行              //myPlaintexPassword，你要加密的东西              //hash，加密后的密文            })          })            }        })</code></pre></li></ul></li></ul><ul><li><p><code>postman</code>接口测试工具</p></li><li><p><code>bcrypt</code>加密工具</p><pre><code>//引入//使用//1、加密bcrypt.genSalt(saltRounds,(err,salt)=&gt;{    bcrypt.hash(myPlaintexPassword,salt,(err,hash)=&gt;{        //saltRounds,加密模式什么的吧填10就行        //myPlaintexPassword，你要加密的东西        //hash，加密后的密文    })})//2、解密bcrypt.compare(myPlaintexPassword,hash,(err,res)=&gt;{  //myPlaintexPassword:前端传来的需要比较的东西    //hash：数据库中存储的密文    //res：估计是返回的true也可以用primise})bcrypt.compare(myPlaintexPassword,hash)            .then(ismatch=&gt;{                //ismatch:boolean值匹不匹配就是这            })</code></pre></li><li><p><code>gravatar</code>全球头像管理的一个东西</p><ul><li><pre><code>//下载引入//使用方法：const avatar = gravatar.url(&#39;123456.@qq.com&#39;,{s:&#39;200&#39;, r: &#39;pg&#39;, d: &#39;404&#39;})//avatar就是头像的url，s:图片大小 r：图片格式 d：图片没有的话默认图片</code></pre></li></ul></li></ul><ul><li><p><code>jsonwebtoken</code>第三方token生成工具</p><ul><li><pre><code>//下载引入//使用：//1、加密生成jwt.sign(&#39;规则&#39;,&#39;加密名字&#39;,&#39;过期时间&#39;,&#39;回调函数&#39;)//规则：要加密的json数据//加密名字：secret,设置在配置文件里统一使用修改//过期时间： {expiresIn: 3600}//回调函数： （err,token）=&gt;{ res.json({token:&#39;mrwu &#39;+token}) }</code></pre></li></ul></li><li><p><code>passport-jwt  passport</code></p><ul><li><pre><code>//下载引入//中间件初始化app.use(passport.initialize())//接下来我们还需要对passport进行一些配置，所以在config下面新建一个passport.js文件。然后将此文件在入口文件中引入require(&quot;./config/passport&quot;)(passport);</code></pre></li><li><p>然后在passport文件中，我们需要使用passport-jwt中间件，所以我们需要在passport中引入passport-jwt、mongoose、keys.js、models/Users.js</p><pre><code>var JwtStrategy = require(&#39;passport-jwt&#39;).Strategy,    ExtractJwt = require(&#39;passport-jwt&#39;).ExtractJwt;    const mongoose = require(&quot;mongoose&quot;);    const User = mongoose.model(&quot;users&quot;);    const keys = require(&quot;../config/keys&quot;);var opts = {}opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();  //通过配置信息来生成jwt的请求，验证这个tokenopts.secretOrKey = keys.secretOrKey;module.exports = passport =&gt;{     passport.use(new JwtStrategy(opts,function(jwt_payload,done){        console.log(jwt_payload);     }));}</code></pre></li><li><p>随后在<code>api/user.js</code>中做密码的验证，首先在文件中引入passport</p><pre><code>const passport = require(&quot;passport&quot;);     //引入passport中间件</code></pre></li><li><pre><code>//$route GET api/users/current//@desc return current user//@access private//验证token得到用户信息//使用passport-jwt验证tokenrouter.get(&quot;/current&quot;,passport.authenticate(&quot;jwt&quot;,{session:false}),(req,res)=&gt;{    res.json({msg:&quot;success&quot;}); })</code></pre></li><li><p>此时可以使用postman来测试接口，在/current下使用<code>key:Authorization</code>；<code>value：token</code>值来测试是否成功。如果测试成功可以打印出用户信息，我们就可以用jwt_payload来登录。将passport里面的export修改为下面：</p><pre><code>module.exports = passport =&gt;{     passport.use(new JwtStrategy(opts,function(jwt_payload,done){        // console.log(jwt_payload);   //jwt_payload就是用户信息        User.findById(jwt_payload.id)            .then(user =&gt;{                if(user){                    return done(null,user);                }                return done(null,false);            })            .catch(err =&gt; console.log(err));     }));}</code></pre><p>我们应该让他返回用户信息，修改user.js中的路由返回值</p><pre><code>router.get(&quot;/current&quot;,passport.authenticate(&quot;jwt&quot;,{session:false}),(req,res)=&gt;{</code></pre></li></ul></li></ul><pre><code>    res.json(req.user); })```此时再用postman测试将返回token所对应的用户信息但是我们并不需要返回所有的用户信息，包括密码什么的，所以我们使用一个对象，将部分用户信息包装在对象中来显示部分用户信息```router.get(&quot;/current&quot;,passport.authenticate(&quot;jwt&quot;,{session:false}),(req,res)=&gt;{    res.json({        id:req.user.id,        name:req.user.name,        email:req.user.email    }); })```此时在用postman测试将只会显示部分用户信息。总结一下，在上一节中主要是为了获取用户的token，token就像一个令牌，我们只有拿这个令牌才能向服务器去请求用户的信息，这一节我们使用/current接口，用passport-jwt来验证token，验证成功之后获得用户信息。</code></pre><ul><li><p>身份验证权限控制</p><ul><li>设置身份字段：identity</li><li>注册时加入身份</li><li>登录时token生成规则加入identity</li><li>请求资源时将identity字段返回</li></ul></li><li><p>增删改查接口 ：略</p></li><li><p>前后端连载</p><ul><li><p>vue创建项目</p><pre><code>vue create client选配置babel、router、vuex使用history使用package.js模板是否保存y/ncd clientnpm run serve</code></pre></li><li><pre><code>连载需要第三方模块concurrently安装并配置就可以在前端文件夹的package.js中配置&quot;script&quot;: {    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,    &quot;build&quot;: &quot;vue-cli-service build&quot;,    &quot;start&quot;: &quot;npm run serve&quot;}在后端文件加的package.js中配置&quot;Script&quot;{    &quot;client-install&quot;: &quot;npm install --prefix client&quot;,    &quot;client&quot;: &quot;npm start --prefix client&quot;,    &quot;start&quot;:     &quot;node server.js&quot;,    &quot;server&quot;: &quot;nodemon server.js&quot;,&quot;dev&quot;: &quot;concurrently \&quot;npm run server\&quot; \&quot;npm run client\&quot;   &quot;}这样前后端就一起启动了</code></pre></li><li></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习回顾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图书管理系统思考</title>
    <link href="/2020/04/10/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/"/>
    <url>/2020/04/10/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<ul><li>学生端<ul><li>查询功能<ul><li>查询藏书信息<ul><li>图书名或关键字查询，</li></ul></li><li>查看个人信息</li><li>查询已借书籍</li></ul></li><li>修改密码</li></ul></li><li>工作人员后台管理<ul><li>获取借阅书籍编号</li><li>获取借阅学生学号</li><li>借出操作<ul><li>改变书籍状态：现有已预定已借出</li><li>将书籍的持有者改为借阅者的用户名</li></ul></li><li>还书操作</li><li>查看是否逾期，及逾期费用</li><li>更改自己的密码</li></ul></li><li>超管<ul><li>学生信息录入与注销</li><li>书籍的录入与遗失书籍的删除</li><li>修改密码</li></ul></li></ul><p>后台管理</p><ul><li><p>登录页</p></li><li><p>主页</p><p>头部：</p><ul><li>左：图标+文字</li><li>右： 时间+登录/退出</li></ul><p>左边菜单：</p><ul><li>图书管理<ul><li>添加图书</li><li>所有图书</li><li>机构审核</li></ul></li><li>书籍列表<br>* </li><li>借阅查看</li><li>管理员信息</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue技术栈</title>
    <link href="/2020/04/10/vue%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <url>/2020/04/10/vue%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>##vue技术栈</p><ol><li><p>vue</p></li><li><p>vue-router</p></li><li><p>ui 库</p><ul><li><p>element-ui /bootstrap-vue /ant-design-vue 等</p></li><li><p>mint-ui(移动端)</p></li></ul></li><li><p>vuex</p></li><li><p>lodash(util库) /ramda /remeda</p></li><li><p>axios</p></li><li><p>axios-mock-adapter</p></li><li><p>webpack</p></li><li><p>yoso</p></li><li><p>husky</p></li><li><p>jest</p></li><li><p>puppeteer</p></li><li></li></ol><ul><li>mock</li><li>webpack</li><li>工程组件模板 - yoso</li><li>husky</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios笔记</title>
    <link href="/2020/04/10/axios%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/10/axios%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p><strong>Axios 是一个基于 <a href="https://link.jianshu.com/?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise" target="_blank" rel="noopener">Promise</a> 的 HTTP 库，可以用在浏览器和 node.js 中</strong></p><p>##1. 特性</p><ul><li>在浏览器中创建 <a href="https://link.jianshu.com/?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequests</a></li><li>在 node.js 则创建 <a href="https://link.jianshu.com/?t=http%3A%2F%2Fnodejs.org%2Fapi%2Fhttp.html" target="_blank" rel="noopener">http</a> 请求</li><li>支持 <a href="https://link.jianshu.com/?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise" target="_blank" rel="noopener">Promise</a> API</li><li>支持拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 <a href="https://link.jianshu.com/?t=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCross-site_request_forgery" target="_blank" rel="noopener">XSRF</a></li></ul><h2 id="2-浏览器支持"><a href="#2-浏览器支持" class="headerlink" title="2. 浏览器支持"></a>2. 浏览器支持</h2><p>  支持Chrome，火狐，Edge，IE8+等</p><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><ul><li><p>npm 安装</p><pre><code>$ npm install axios</code></pre></li><li><p>使用bower：</p><pre><code>$ bower install axios</code></pre></li><li><p>直接使用cdn：</p><pre><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre></li></ul><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h2><ul><li><p>get请求</p><pre><code>// 为给定 ID 的 user 创建请求axios.get(&#39;/user?ID=12345&#39;)  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });// GET 参数可以放到params里（推荐）axios.get(&#39;/user&#39;, {    params: {      ID: 12345    }  })  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });// 还可以使用ECMAScript 2017里的async/await，添加 `async` keyword to your outer function/method.async function getUser() {  try {    const response = await axios.get(&#39;/user?ID=12345&#39;);    console.log(response);  } catch (error) {    console.error(error);  }}</code></pre></li><li><p>执行post请求</p><pre><code>axios.post(&#39;/user&#39;, {    firstName: &#39;Fred&#39;,    lastName: &#39;Flintstone&#39;  })  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });</code></pre></li></ul><h2 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5. 拦截器"></a>5. 拦截器</h2><p>可以自定义拦截器，在在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p><pre><code>// 添加请求拦截器axios.interceptors.request.use(function (config) {    // 在发送请求之前做些什么    return config;  }, function (error) {    // 对请求错误做些什么    return Promise.reject(error);  });// 添加响应拦截器axios.interceptors.response.use(function (response) {    // 对响应数据做点什么    return response;  }, function (error) {    // 对响应错误做点什么    return Promise.reject(error);  });</code></pre><p>如果你想在稍后移除拦截器，可以这样：</p><pre><code class="js">var myInterceptor = axios.interceptors.request.use(function () {/*...*/});axios.interceptors.request.eject(myInterceptor);</code></pre><p>可以为自定义 axios 实例添加拦截器</p><pre><code class="js">var instance = axios.create();instance.interceptors.request.use(function () {/*...*/});</code></pre><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><pre><code class="js">axios.get(&quot;/user/12345&quot;)  .catch(function (error) {    if (error.response) {      // 请求已发出，但服务器响应的状态码不在 2xx 范围内      console.log(error.response.data);      console.log(error.response.status);      console.log(error.response.headers);    } else {      // Something happened in setting up the request that triggered an Error      console.log(&quot;Error&quot;, error.message);    }    console.log(error.config);  });</code></pre><p>可以使用 <code>validateStatus</code> 配置选项定义一个自定义 HTTP 状态码的错误范围。</p><pre><code class="js">axios.get(&quot;/user/12345&quot;, {  validateStatus: function (status) {    return status &lt; 500; // 状态码在大于或等于500时才会 reject  }})</code></pre><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p>使用 <em>cancel token</em> 取消请求</p><blockquote><p>Axios 的 cancel token API 基于<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-cancelable-promises" target="_blank" rel="noopener">cancelable promises proposal</a></p></blockquote><p>可以使用 <code>CancelToken.source</code> 工厂方法创建 cancel token，像这样：</p><pre><code class="js">const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get(&#39;/user/12345&#39;, {  cancelToken: source.token}).catch(function(thrown) {  if (axios.isCancel(thrown)) {    console.log(&#39;Request canceled&#39;, thrown.message);  } else {    // handle error  }});axios.post(&#39;/user/12345&#39;, {  name: &#39;new name&#39;}, {  cancelToken: source.token})// cancel the request (the message parameter is optional)source.cancel(&#39;Operation canceled by the user.&#39;);</code></pre><p>还可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token：</p><pre><code class="js">var CancelToken = axios.CancelToken;var cancel;axios.get(&quot;/user/12345&quot;, {  cancelToken: new CancelToken(function executor(c) {    // executor 函数接收一个 cancel 函数作为参数    cancel = c;  })});// 取消请求cancel();</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue入门</title>
    <link href="/2020/04/09/vue%E5%85%A5%E9%97%A8/"/>
    <url>/2020/04/09/vue%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vue入门"><a href="#vue入门" class="headerlink" title="vue入门"></a>vue入门</h1><h2 id="Vue-js安装"><a href="#Vue-js安装" class="headerlink" title="Vue.js安装"></a>Vue.js安装</h2><ol><li>独立版本</li></ol><p>2，使用CDN方法</p><p>以下推荐国外比较稳定的两个CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p><p>静态文件CDN（国内）：<code>https : //cdn.staticfile.org/vue/2.2.2/vue.min.js</code></p><p>unpkg：<code>https : //unpkg.com/vue/dist/vue.js，</code>保持和npm发布的最新版本一致。</p><p>cdnjs：<code>https : //cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</code><br>3. NPM方法</p><p>由于npm安装速度慢，本教程使用了淘宝的补充及其命令cnpm，安装使用介绍参照：使用淘宝NPM。</p><p>npm版本需要大于3.0，如果低于此版本需要升级它：</p><pre><code>＃查看版本$ npm - v 2.3 。0＃升级npm cnpm安装npm - g＃升级或安装cnpm npm安装cnpm - g</code></pre><p>在用Vue.js构建大型应用时推荐使用NPM安装：</p><pre><code>＃最新稳定版$ cnpm install vue</code></pre><hr><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</p><pre><code># 全局安装 vue-cli$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes   vue-cli · Generated &quot;my-project&quot;.   To get started:     cd my-project     npm install     npm run dev   Documentation can be found at https://vuejs-templates.github.io/webpack</code></pre><p>进入项目，安装并运行：</p><pre><code>$ cd my-project$ cnpm install$ cnpm run dev DONE  Compiled successfully in 4388ms&gt; Listening at http://localhost:8080</code></pre><h2 id="Vue-js-起步"><a href="#Vue-js-起步" class="headerlink" title="Vue.js 起步"></a>Vue.js 起步</h2><p>每个 Vue 应用都需要通过实例化 Vue 来实现。</p><p>语法格式如下：</p><pre><code>var vm = new Vue({  // 选项})</code></pre><p>接下来让我们通过实例来看下 Vue 构造器中需要哪些内容：</p><p>实例</p><pre><code>&lt;div id=&quot;vue_det&quot;&gt;    &lt;h1&gt;site : {{site}}&lt;/h1&gt;    &lt;h1&gt;url : {{url}}&lt;/h1&gt;    &lt;h1&gt;{{details()}}&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue({        el: &#39;#vue_det&#39;,        data: {            site: &quot;菜鸟教程&quot;,            url: &quot;www.runoob.com&quot;,            alexa: &quot;10000&quot;        },        methods: {            details: function() {                return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;            }        }    })&lt;/script&gt;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/04/09/hello-world/"/>
    <url>/2020/04/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue.router</title>
    <link href="/2020/03/20/vue.component/"/>
    <url>/2020/03/20/vue.component/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-component"><a href="#vue-component" class="headerlink" title="vue.component"></a>vue.component</h1><h2 id="Vue-js-组件"><a href="#Vue-js-组件" class="headerlink" title="Vue.js 组件"></a>Vue.js 组件</h2><p>组件（Component）是 Vue.js 最强大的功能之一。</p><p>组件可以扩展 HTML 元素，封装可重用的代码。</p><p>组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：</p><p>注册一个全局组件语法格式如下：</p><p><code>Vue.component(tagName, options)</code></p><p>tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件：</p><p><code>&lt;tagName&gt;&lt;/tagName&gt;</code></p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>所有实例都能用全局组件。</p><pre><code>全局组件实例注册一个简单的全局组件 runoob，并使用它：&lt;div id=&quot;app&quot;&gt;    &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt;&lt;script&gt;// 注册Vue.component(&#39;runoob&#39;, {  template: &#39;&lt;h1&gt;自定义组件!&lt;/h1&gt;&#39;})// 创建根实例new Vue({  el: &#39;#app&#39;})&lt;/script&gt;</code></pre><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>我们也可以在实例选项中注册局部组件，这样组件只能在这个实例中使用：</p><pre><code>局部组件实例注册一个简单的局部组件 runoob，并使用它：&lt;div id=&quot;app&quot;&gt;    &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt;&lt;script&gt;var Child = {  template: &#39;&lt;h1&gt;自定义组件!&lt;/h1&gt;&#39;}// 创建根实例new Vue({  el: &#39;#app&#39;,  components: {    // &lt;runoob&gt; 将只在父模板可用    &#39;runoob&#39;: Child  }})&lt;/script&gt;</code></pre><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>prop 是子组件用来接受父组件传递过来的数据的一个自定义属性。</p><p>父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 “prop”：</p><pre><code>Prop 实例&lt;div id=&quot;app&quot;&gt;    &lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt;// 注册Vue.component(&#39;child&#39;, {  // 声明 props  props: [&#39;message&#39;],  // 同样也可以在 vm 实例中像 &quot;this.message&quot; 这样使用  template: &#39;&lt;span&gt;{{ message }}&lt;/span&gt;&#39;})// 创建根实例new Vue({  el: &#39;#app&#39;})&lt;/script&gt;</code></pre><h3 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h3><p>类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：</p><pre><code>Prop 实例&lt;div id=&quot;app&quot;&gt;    &lt;div&gt;      &lt;input v-model=&quot;parentMsg&quot;&gt;      &lt;br&gt;      &lt;child v-bind:message=&quot;parentMsg&quot;&gt;&lt;/child&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 注册Vue.component(&#39;child&#39;, {  // 声明 props  props: [&#39;message&#39;],  // 同样也可以在 vm 实例中像 &quot;this.message&quot; 这样使用  template: &#39;&lt;span&gt;{{ message }}&lt;/span&gt;&#39;})// 创建根实例new Vue({  el: &#39;#app&#39;,  data: {    parentMsg: &#39;父组件内容&#39;  }})&lt;/script&gt;</code></pre><p>以下实例中使用 v-bind 指令将 todo 传到每一个重复的组件中：</p><pre><code>Prop 实例&lt;div id=&quot;app&quot;&gt;    &lt;ol&gt;    &lt;todo-item v-for=&quot;item in sites&quot; v-bind:todo=&quot;item&quot;&gt;&lt;/todo-item&gt;      &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;Vue.component(&#39;todo-item&#39;, {  props: [&#39;todo&#39;],  template: &#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39;})new Vue({  el: &#39;#app&#39;,  data: {    sites: [      { text: &#39;Runoob&#39; },      { text: &#39;Google&#39; },      { text: &#39;Taobao&#39; }    ]  }})&lt;/script&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习markdown的语法</title>
    <link href="/2020/02/29/markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/02/29/markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>要加粗的文字左右分别用两个*号包起来</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>要倾斜的文字左右分别用一个*号包起来</p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>要加删除线的文字左右分别用两个~~号包起来</p><a id="more"></a><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…</p><p>示例：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p><hr><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>语法：</p><p><strong>![图片alt](图片地址 ‘’图片title’’)</strong></p><p><strong>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</strong><br><strong>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</strong></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>**语法：</p><p>**<a href="超链接地址" title="超链接title">超链接名</a><br>**title可加可不加</p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，<br>是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以<br>用html语言的a标签代替。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>语法：<br>无序列表用 - + * 任何一种都可以</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p><strong>注意：- + * 跟内容之间都要有一个空格</strong></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>语法：<br>数字加点</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p><strong>注意：序号跟内容之间要有空格</strong></p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法：</p><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><p>第二行分割表头和内容。</p><ul><li>有一个就行，为了对齐，多加了几个<br>文字默认居左</li><li>两边加：表示文字居中</li><li>右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>语法：<br>单行代码：代码之间分别用一个反引号(英文输入法~键不按shift)包起来</p><pre><code>`代码内容`</code></pre><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><p>(<code>)  代码...  代码...  代码...(</code>)</p><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。<br>这里只是用来演示，实际中去掉两边小括号即可。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>markdown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>express中间件学习</title>
    <link href="/2020/02/29/express%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/02/29/express%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>##中间件格式：</p><pre><code>//全局app.use((req,res,next)=&gt;{  next()//放行，执行下边的路径访问})//带路径，只过滤这个路径的访问app.use(&#39;/login&#39;,(req,res,next)=&gt;{  next()})</code></pre><p>##中间件应用：</p><ul><li>404处理：<pre><code>app.use((req,res,next)=&gt;{res.status(404).send(&#39;404 not found&#39;)})</code></pre></li><li>500处理;<pre><code>app.use((err,req,res,next)=&gt;{res.status(500).send(err.message)})//触发方法：1.在上边的路径请求中判断并抛出error：throw new Error(&#39;error message&#39;)2。异步处理无法触发要使用next（）：在异步处理中将err信息放在next（）中即可在发生错误时触发500中间件3.使用trycatch捕获异常**trycatch可以捕获同步函数错误异步函数错误但是不能捕获其他错误，如promise对象错误，回调函数错误app.get(&#39;/&#39;,async(req,res,next)=&gt;{try{await user.find({name:&#39;zhangsan&#39;})}  catch(ex){next(ex)}})</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>express cookie使用</title>
    <link href="/2020/02/29/express%20cookie%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/29/express%20cookie%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>##1.安装</p><pre><code class="js">npm install cookie-parser --save</code></pre><p>##2.引入</p><pre><code class="js">const cookieParser=require(&quot;cookie-parser&quot;)</code></pre><p>##3.设置中间件</p><pre><code class="js">app.use(cookieParser())</code></pre><p>##4.设置cookie</p><pre><code class="js">res.cookie(&quot;name&quot;,&#39;zhangsan&#39;,{maxAge: 900000, httpOnly: true});参数一：cookie名字参数二：cookie值参数三： {maxage：最大存活时间，httponly：true通过程序（JS 脚本、applet 等）将无法读取到COOKIE 信息，防止 XSS 攻击的产生,domindomain: &quot;ccc.com&quot;设置域名，满足顶级域名的访问都能共享cookie }</code></pre><p>##5.获取cookie</p><pre><code class="js">req.cookie.name</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>express cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue.js安装</title>
    <link href="/2020/02/29/vue.js/"/>
    <url>/2020/02/29/vue.js/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-js安装"><a href="#vue-js安装" class="headerlink" title="vue.js安装"></a>vue.js安装</h1><ol><li><p>独立版本</p></li><li><p>使用cdn方法</p><p>以下推荐国外比较稳定的两个CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p><ul><li>静态文件CDN（国内）：<code>https : //cdn.staticfile.org/vue/2.2.2/vue.min.js</code></li><li>unpkg：<code>https : //unpkg.com/vue/dist/vue.js，</code>保持和npm发布的最新版本一致。</li><li>cdnjs：<code>https : //cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</code></li></ul></li><li><p>npm安装</p><p>由于npm安装速度慢，本教程使用了淘宝的补充及其命令cnpm，安装使用介绍参照：使用淘宝NPM。npm版本需要大于3.0，如果低于此版本需要升级它：</p><pre><code>＃查看版本$ npm - v 2.3 。0＃升级npm cnpm安装npm - g＃升级或安装cnpm npm安装cnpm - g</code></pre><p>在用Vue.js构建大型应用时推荐使用NPM安装：</p><pre><code>＃最新稳定版$ cnpm install vue</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>express开放静态资源文件</title>
    <link href="/2020/02/29/express%E5%BC%80%E6%94%BE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <url>/2020/02/29/express%E5%BC%80%E6%94%BE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>创建public文件夹，将静态资源全部放入<br>在server.js中</p><pre><code class="js">app.use(&quot;/static/&quot;,express.static(path.join(__dirname, &#39;static&#39;)))第一个参数是访问时要加的路径，第二个参数是要开放的文件夹路径  path是一个核心模块  __dirname是当前文件所在目录的绝对目录join是拼接目录的方法</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx 安装</title>
    <link href="/2020/02/29/nginx%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/02/29/nginx%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx安装："><a href="#nginx安装：" class="headerlink" title="nginx安装："></a>nginx安装：</h1><ul><li>下载：官网<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>Stable Vision(稳定版本)<ul><li>安装：Windows下解压即可<br>#nginx使用的几个简单命令：</li><li>启动：windows下直接点击nginx.exe即可启动</li><li>关闭：</li></ul></li></ul><ul><li>软关闭：当前文件夹下命令行执行<br><code>nginx -s quit</code></li><li>硬关闭：当前文件夹下命令行执行<br><code>nginx -s stop</code><ul><li>重新加载配置文件：<code>nginx -s reload</code></li><li>重新启动nginx：<code>nginx -s reopen</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的安装</title>
    <link href="/2019/10/22/git%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2019/10/22/git%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>###git安装教程</p><p>这里的git指的是本地的git.</p><p>让我们开始吧！</p><ol><li>打开git的下载地址<a href="https://www.git-scm.com/download/" target="_blank" rel="noopener">https://www.git-scm.com/download/</a></li></ol><a id="more"></a><pre><code>![百度git](git的安装/baidugit.png)</code></pre><ol start="2"><li><p>打开后点击download</p><p> <img src="git%E7%9A%84%E5%AE%89%E8%A3%85/download.png" srcset="/img/loading.gif" alt="点击download"></p></li><li><p>下载完成后双击运行</p><p> <img src="git%E7%9A%84%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85.png" srcset="/img/loading.gif" alt="双击运行"></p></li><li><p>接着看需要点</p><p> <img src="git%E7%9A%84%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%851.png" srcset="/img/loading.gif" alt="配置"></p><p> <img src="git%E7%9A%84%E5%AE%89%E8%A3%85/%E9%80%89%E6%8B%A9%E9%BB%98%E8%AE%A4%E7%BC%96%E8%BE%91%E5%99%A8.png" srcset="/img/loading.gif" alt="选择默认编辑器"></p></li><li><p>之后跟着一直点next，就好了下载完成后</p><p> <img src="git%E7%9A%84%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="安装成功"></p></li><li><p>接下来就请放心食用吧</p><p> <img src="git%E7%9A%84%E5%AE%89%E8%A3%85/%E6%94%BE%E5%BF%83%E9%A3%9F%E7%94%A8.png" srcset="/img/loading.gif" alt="放心食用"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客的搭建过程</title>
    <link href="/2019/10/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <url>/2019/10/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>##先序</p><p>教程针对hexo框架搭建，有本人踩过的坑，我是在windows上做的，大家参考。</p><a id="more"></a><hr><p>##第一步 安装nodejs</p><p>1.安装地址<a href="http://www.nodejs.org" target="_blank" rel="noopener">http://www.nodejs.org</a></p><p>[图片]url</p><p>2.下载完成后再双击安装，安装过程就一直next就好了</p><p>3.安装成功后可以通过命令行验证</p><p>4.win+r 输入cmd打开命令行窗口输入node -v   npm -v</p><p>5.我们还需要淘宝的镜像源来下载，要不直接下载太慢</p><p>命令为： </p><p>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a></p><p>下载完成后可以输入： cnpm 验证。</p><hr><p>##第二步 通过cnpm 来安装hexo博客框架</p><p>1.命令行敲入命令：cnpm install -g hexo-cli</p><p>2.装好后用 hexo -v 来查看版本</p><hr><p>##第三步 搭建博客</p><p>1.搭建博客要先建一个blog文件夹（什么地方都可以，自己建）</p><p>可以鼠标操作也可以mkdir blog</p><p>之后所有操作都在这个文件夹里进行，出错了搞不定可以把这个删了，重新来。</p><p>2.然后我们开始用hexo来搭框架</p><p>敲入命令 hexo init 等待一会<br>安装好后，可以在blog内看到生成的文件，就说明安装好了</p><p>然后敲入命令hexo s 启动我们的博客</p><p>然后就可以在浏览器里面访问了，输入localhost:4000就可以看到了</p><p>3.hexo会默认给哦我们生成一个hello world 的文章</p><p>要写文章的话可以使用命令hexo n “文章题目”来新建一个.md的文件</p><p>我们可以使用idea和其他的编辑器来编辑它，它采用的是markdown语言（一种简单的标记语言）<br>关于markdown语法可以在<a href="https://www.jianshu.com/p/335db5716248中查看，也可以自行百度" target="_blank" rel="noopener">https://www.jianshu.com/p/335db5716248中查看，也可以自行百度</a></p><p>编辑好后依次执行（记得回到blog目录下）</p><p>hexo clean</p><p>hexo g</p><p>hexo s</p><p>然后刷新浏览器，就可以看到我们新添加的文章了。</p><p>##第四步 上传到github</p><p>1.之前做的博客只能在自己的电脑上访问，我们现在需要把他布置到github上，让别人能够通过互联网来访问我们的博客。</p><p>做法如下：</p><p>我们先到自己的github上创建一个仓库</p><blockquote><p><strong>仓库名一定要是:你的用户名.github.io</strong></p></blockquote><p>2.创建好后，仓库还是空的</p><p>我们要在blog目录下安装一下git的部署插件</p><p>cnpm install –save hexo-deployer-git</p><p>完成后我们需要配置一下blog目录下的_config.yml文件</p><p>用编辑器打开<br>找到最后的type改成：</p><p>type: git</p><p>repo: <a href="https://github.com/13509791520zsq/13509791520zsq.github.io.git(就是你的仓库里面的地址)" target="_blank" rel="noopener">https://github.com/13509791520zsq/13509791520zsq.github.io.git(就是你的仓库里面的地址)</a></p><p>branch: master</p><p>3.配置好后，我们就需要把本地的文件部署到git上去了</p><p>hexo deploy（或者hexo d）</p><p>中间会需要输入用户名和密码</p><p>之后刷新仓库就会发现仓库里面有了我们本地的文件了</p><p>访问方式就是  “用户名.github.io” 在浏览器上直接打开就可以访问了。</p><p>#第五步 更换主题</p><p>1.推荐一个网址：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></p><p>打开后点击clone and download</p><p>会有一个地址复制下来</p><p>2.输入命令： git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p><p>开始克隆（下载）</p><p>3.下载完成后可以在文件themes下看见yilia</p><p>然后我们就可以配置了</p><p>打开_config.yml文件</p><p>找到theme把后面的landscape改成yilia就好了</p><p>4.接下来依次</p><p>hexo clean</p><p>hexo g</p><p>hexo s（本地的就已经改了）</p><p>hexo d (部署到github上会有延迟等会就可以)</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Filter:过滤器</title>
    <link href="/2019/10/19/filter/"/>
    <url>/2019/10/19/filter/</url>
    
    <content type="html"><![CDATA[<h1 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter:过滤器"></a>Filter:过滤器</h1><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>web中的过滤器:当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li><li>过滤器的作用：<ul><li>一般用于完成通知的操作。如：登陆验证、统一编码处理、敏感字符过滤。。。</li></ul></li></ul><h3 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h3><ul><li>步骤：<ol><li>定义一个类，实现接口Filter<ol start="2"><li>复写方法</li><li>配置拦截路径<ol><li>web.xml配置</li><li>注解配置<br><code>@webFilter(&quot;/*&quot;)//访问所有资源时都会执行该过滤器</code></li></ol></li><li>放行代码：<br><code>filterChain.doFilter(servletRequest,servletResponse);</code></li></ol></li></ol></li></ul><h3 id="过滤器细节："><a href="#过滤器细节：" class="headerlink" title="过滤器细节："></a>过滤器细节：</h3><ul><li><p>web.xml配置</p><pre><code>      &lt;filter&gt;          &lt;filter-name&gt;demo1&lt;/filter-name&gt;          &lt;filter-class&gt;cn.qiqi.web.filter.Filterdemo1&lt;/filter-class&gt;      &lt;/filter&gt;      &lt;filter-mapping&gt;          &lt;filter-name&gt;demo1&lt;/filter-name&gt;          &lt;!-- 拦截路径--&gt;          &lt;url-pattern&gt;/-&lt;/url-pattern&gt;      &lt;/filter-mapping&gt;</code></pre></li><li><p>过滤器执行流程</p><ol><li>执行过滤器</li><li>执行放行后的资源</li><li>回来执行过滤器放行代码下边的代码</li></ol></li><li><p>过滤器生命周期方法</p><ol><li>init: 在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次，用于加载资源。</li><li>doFilter: 每次请求被拦截资源时，会执行。执行多次。</li><li>destroy: 在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭的，则执行一次destroy方法，只执行一次，用于释放资源。</li></ol></li><li><p>过滤器配置详解</p><ul><li>拦截路径配置：<ol><li>具体资源路径：<br> <code>/index.jsp</code></li><li>拦截目录；<br> <code>/user/*</code></li><li>后缀名拦截：<br> <code>*.jsp</code></li><li>拦截所有资源：<br> <code>/*</code></li></ol></li><li>拦截方式配置：资源被访问的方式<ul><li>注解配置：<ul><li>设置dispatcherTypes属性<ol><li>REQUEST : 默认值。浏览器直接请求资源</li><li>FORWARD : 转发访问资源</li><li>INCLUDE : 包含访问资源</li><li>ERROR : 错误跳转资源</li><li>ASYNC : 异步访问资源</li></ol></li><li>web.xml配置<ul><li>设置<dispatcher></dispatcher>标签即可</li></ul></li></ul></li></ul></li></ul></li><li><p>过滤器链（配置多个过滤器）</p><ul><li><p>执行顺序 ：如果有两个过滤器：1和2</p><ol><li>1</li><li>2</li><li>资源执行</li><li>2</li><li>1</li></ol></li><li><p>过滤器先后顺序问题：</p><ol><li>注解配置：按照类名的字符串比较规则比较，值小的先执行</li><li>web.xml配置: <filter-mapping>谁定义在上边，谁先执行</li></ol></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodemon 运行错误解决</title>
    <link href="/2019/10/19/nodemon%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2019/10/19/nodemon%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="nodemon运行-提示错误：无法加载文件-C-Users-gxf-AppData-Roaming-npm-nodemon-ps1，因为在此系统上禁止运行脚本。"><a href="#nodemon运行-提示错误：无法加载文件-C-Users-gxf-AppData-Roaming-npm-nodemon-ps1，因为在此系统上禁止运行脚本。" class="headerlink" title="nodemon运行 提示错误：无法加载文件 C:\Users\gxf\AppData\Roaming\npm\nodemon.ps1，因为在此系统上禁止运行脚本。"></a>nodemon运行 提示错误：无法加载文件 C:\Users\gxf\AppData\Roaming\npm\nodemon.ps1，因为在此系统上禁止运行脚本。</h3><blockquote><p> 这是你笔记本禁止运行脚本，解决办法：</p></blockquote><ol><li><p>管理员身份打开powerShell</p></li><li><p>输入set-ExecutionPolicy RemoteSigned </p></li><li><p>nodemon server.js 可以用了</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
